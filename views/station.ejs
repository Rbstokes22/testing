<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greenhouse Controller</title>
    <style>
        
        button {
            border: 2px solid black;
            border-radius: 5px;
            min-height: 3em;
        }

        input {
            height: 2em;
        }

        body {
            color: black;
        }

        #title {
            text-align: center;
            font-size: 1.5em;
        }

        .logFWbut {
            text-align: center;
            background-color: black;
            color: white;
            border-radius: 5px;
            font-weight: 700;
            margin: 10px 0px 10px 0;
            justify-content: center;
        }

        #FWbut {background-color: red;} 

        /* 
        Creates as many col that will fit into container, if there is space
        will fill row with as many col as possible. Each col will have a min
        wid of 200px and a max of 1 fraction of available space, allowing
        col to grow to fill available space  
        */
        #container { 
            display: grid;
            grid-template-columns: 1fr; /* default 1 column */
            gap: 10px;
        }

        @media (min-width: 600px) {
            #container { /* 2 cols on wider screen */
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .item {
            background-color: rgb(128, 251, 255);
            padding: 20px;
            text-align: left;
            border: 2px solid black;
        }

        .smallItem {
            padding: 5px;
            border: 2px solid black;
            text-align: left;
        }

        .con {
            display: grid;
            grid-template-columns: repeat(4, minmax(75px, 1fr));
            grid-template-rows: auto;
            gap: 10px;
            align-self: start; /* prevent stretching */
        }

        .conLab {
            color: rgb(255, 230, 0);
            font-weight: 900;
            background-color: rgb(0, 26, 255);
        }

        #specDisp {
            display: grid;
            grid-template-columns: 60px auto; /* 2 columns */
            grid-template-rows: auto;
            gap: 5px;
            align-self: start;
            white-space: nowrap;
            background-color: rgb(0, 0, 0);
            color: rgb(255, 255, 255);
        }

        .trends {background-color: white;}

        .span2 {grid-column: span 2;}
        .span3 {grid-column: span 3;}
        .span4 {grid-column: span 4;}
        .selected {background-color: rgb(255, 166, 0);}
        .boundBust, .badRange, .warning {
            background-color: rgb(196, 0, 0);
            color: white;
        }
        
        .dark {
            background-color: black;
            color: white;
        }
        .blinker {background-color: red;}

    </style>
</head>
<body onload="loadPage()">
    <p id="title">MysteryGraph Greenhouse</p>
    <div id="otaUpd"></div>
    <div id="container">
        <div id="mainCon" class="item"></div>
        <div id="tempCon" class="item"></div>
        <div id="humCon" class="item"></div>
        <div id="soil0Con" class="item"></div>
        <div id="soil1Con" class="item"></div>
        <div id="soil2Con" class="item"></div>
        <div id="soil3Con" class="item"></div>
        <div id="lightCon" class="item"></div>
        <div id="specCon" class="item"></div>
        <div id="re0Con" class="item"></div>
        <div id="re1Con" class="item"></div>
        <div id="re2Con" class="item"></div>
        <div id="re3Con" class="item"></div>
    </div> <!-- contains all periph containers-->
    
    <div id="log"></div>

    <button id="logBut" class="logFWbut" onclick="openLog()">Open Log</button>

    <script>

    // 90% done. Halfway done with markers for soil and photo. Continuing building
    // this and streamline it to make it much cleaner. On mouse up, the relative positon
    // percentage should be computed, like where does it fall in regards to the bar
    // width percentage wise. This way, local storage saves that, and on reload it will
    // place the markers back in the correct position, also with different views we want the
    // placed marker to stay in the same position relative to the bar. Maybe make the bar 
    // thicker, not sure yet? Maybe have a touch and hold feature, that will allow you to
    // delete all markers or what now. Maybe on mouse down, the bar increases height to
    // allow you to better see your positon, maybe with a cursor. Not sure yet.
    // 

    // Built relay day selection, tested and works. 

    // Once that is complete, build a display only div element for all analog,
    // so soil and photo. This can be like the spec display, but have a fixed bar
    // that reps 0 - 4095, and an object that moves along that bar. Have a calibrate
    // button, only for the soil, dark is already calibratable for the photo and fine.
    // This will pop up a prompt that allows the user to add in a numerical value for 
    // dry and wet, or maybe a button that says calibrate dry, with a value box, or 
    // you can hold it and it will calibrate to the current setting, same with wet.
    // This way it is calibrated to the user, and they can mess with it as they see fit.

    // Code functionality complete. Cleaning up code currently on 
    // START CONTAINER SUPPLEMENTARY FUNCTIONS
    // Finish revising and commenting. Once complete, adjust css for layout
    // and effects until it looks pretty. Once complete, move to ESP32.

    // Tested on ESP32 with several errors. Made comments on main.cpp, will
    // troubleshoot before continuing on here.

    // ATTENTION: Logic throughout contains certain name specific methods using
    // naming. So if anything is modified, check all dependencies. i.e. relay
    // checks include if (name.includes("re")), you would want to ensure that
    // any changes update that as well, for example if you renamed temp to 
    // temperature, this could cause problems.

    // Network and Sockets
    const re = /(https?):\/\/([a-zA-Z0-9.-]+(:\d+)?)/; // Regex
    const URLdata = re.exec(window.location.href);
    const URLprotocol = URLdata[1]; // http or https
    const URLbody = URLdata[2]; // main url
    const OTAURL = `${URLprotocol}://${URLbody}/OTACheck`; 
    const logURL = `${URLprotocol}://${URLbody}/getLog`;
    const webSktURL = `ws://${URLbody}/ws`;
    // const webSktURL = "ws://greenhouse.local/ws"; // Testing only on actual device without upload.

    // Elements
    const OTAdisp = document.getElementById("otaUpd");

    // Key names are colors that correspond with the JSON socket data. arr[0]
    // is the wavelength, arr[1] is the display bar color, and arr[2] is the 
    // color darkness, 0 (light) or 1 (dark), to adjust background text.
    const COLORS = {
        "violet": ["415nm", "violet", 1], "indigo": ["445nm", "indigo", 1],
        "blue": ["485nm", "blue", 1], "cyan": ["515nm", "cyan", 0],
        "green": ["555nm", "green", 1], "yellow": ["590nm", "yellow", 0],
        "orange": ["630nm", "orange", 0], "red": ["680nm", "red", 1],
        "nir": ["NIR", "rgb(140, 0, 0)", 1], "clear": ["Clear", "white", 0]
    };
    
    const MAX_SPEC_PX = 250; // Max color count pixels.

    // Intervals (millis)
    const POLL_INTV = 1000; // Poll interval to run GET_ALL.
    const CHK_OTA_INTV = 86400000; // OTA check run.
    const CLEAR_REQ_INTV = 60000; // Clear exp skt req if non-response.
    const FW_CHECK_INTV = 12 * 60 * 60 * 1000; // Check for new firmware.

    // Flags 
    let Flags = {SKTconn:false, openLog:true};

    // Other
    const maxID = 255; // Used to reset ID num to 0 when this value is reached.
    const logDelim = ';';
    const RE_OFF = 255; // Signals relay is not attached.
    let isCelcius = false;
    const sensUpBg = ["yellow", "rgb(0, 224, 27)"]; // Sensor up background clr
    let specDisplay = 'C'; // 'C'urrent, 'A'verages, 'P'rev Averages.
    const DAYS = ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"];
    let reDays = [0, 0, 0, 0]; // Relay day tracker for socket send only.

    // All commands from socketHandler.hpp. These must correspond with the
    // enum. Will be used to return the index num, which will be the cmd.
    let CMDS = [null, // Used to index to a +1
        "GET_ALL", "CALIBRATE_TIME", "NEW_LOG_RCVD", "RELAY_CTRL", 
        "RELAY_TIMER", "RELAY_TIMER_DAY", "ATTACH_RELAYS", "SET_TEMPHUM", 
        "SET_SOIL", "SET_LIGHT", "SET_SPEC_INTEGRATION_TIME", "SET_SPEC_GAIN", 
        "CLEAR_AVERAGES", "CLEAR_AVG_SET_TIME", "SAVE_AND_RESTART", 
        "GET_TRENDS"];

    // Declare all vars here, to save space. idNum is used to keep track of
    // socket commands, allData contains all sensor data, and log contains
    // all log entries.
    let socket, poll, clearReqID, requestIDs = {}, idNum = 0,
        allData = {}, log = [], Expansions = {};

    // START CONTAINER BUILDING ================================================

    // element build. Requires the parent ID, and both the read only and 
    // input objects. Returns constructed object.
    let eleBuild = function(parentID, readOnly, inputs) {
        this.parentID = parentID; // Used to link it to parent container.
        this.readOnly = readOnly; // Sensor and setting data.
        this.inputs = inputs; // Interactive.
        this.buttonID = `${parentID}Exp`; // Expansion button.
        return this;
    }

    // Read only build. Requires the element type, its text, and and array
    // of all classes pertaining to it. Returns constructed object.
    let RObuild = function(eleType, text, classes) {
        this.eleType = eleType; // element type. i.e. "div".
        this.text = text; // Default input text.
        this.classes = classes; // array of classes.
        return this;
    }

    // Input build. Builds the interactive portion to make adjustments to
    // system settings. Pass null if non-exist. Returns constructed object.
    let inputBuild = function(ranges, eleType, label, incBut, 
        classes, dataPtr, rangeMap, specMap, butFunc) {

        this.ranges = ranges; // All the applicable input ranges
        this.eleType = eleType; // element type. i.e. "input".
        this.label = label; // input box label.
        this.incBut = incBut; // bool. Include button.
        this.classes = classes; // array of classes.
        this.dataPtr = dataPtr; // pointer/key of allData JSON.

        // Maps. The range map is an array that has display values with an
        // index that corresponds with an actual numberical value. Special
        // maps are used for values outside of the typical range and are 
        // passed as objects, with idx 0 being the display, and idx 1 being the
        // value.
        this.rangeMap = rangeMap; 
        this.specMap = specMap;
        this.butFunc = butFunc; // function applied to button onclick.
        return this;
    }

    // Command build. Pass the command string, and the callback function. 
    // Returns constructed object that will be called when submit is selected.
    let cmdBuild = function(cmd, callBack) {
        this.cmd = cmd;
        this.callBack = callBack;
        return this;
    }

    // Range build. Pass the min, max, and step values. This will be used for 
    // inputs and to run quality checks for submitting data.
    let rangeBuild = function(min, max, step) {
        this.min = min; // range minimum
        this.max = max; // range max
        this.step = step; // Step size
        return this;
    }

    // Primary build container. Each sub-container will be built here. Builds
    // Read Only (RO), which will be the display, and Input (INP), which allows
    // the client to change settings. All params from re to reTimer are 
    // commands that use action buttons. This is a cookie-cutter build method.
    let buildCon = (name, re, reSet, altSet, darkSet, integ, gain, 
        reTimer, ranges, includeLabel = false) => {
        
        let RO = {}, INP = {}; // Read only and Input objects.

        // Add the container class to give the grid attributes and allow input
        // label.
        const parent = document.getElementById(`${name}Con`);
        parent.classList.add("con"); // Add class upon creation.

        // Build all containers depending on the params.
        if (includeLabel) buildConLabel(parent, name);
        buildConSpecial(name, ranges, RO, INP,); // No commands attached.
        if (re) buildConRelay(re, name, ranges, RO, INP);
        if (reSet) buildConRelaySet(reSet, name, ranges, RO, INP);
        if (altSet) buildConAlertSet(altSet, name, ranges, RO, INP);
        if (darkSet) buildConDarkSet(darkSet, name, ranges, RO, INP);
        if (integ) buildConIntegrationSet(integ, name, ranges, RO, INP);
        if (gain) buildConGainSet(gain, name, ranges, RO, INP);
        if (reTimer) buildConRelayTimerSet(reTimer, name, ranges, RO, INP);

        // Once all selection have been built, build expand button and
        // adjustment bar.
        RO[`${name}ConExp`] = new RObuild("button", "Expand", ["span4"]);

        return new eleBuild(`${name}Con`, RO, INP); // Return built object.
    }

    // Requires the parent container, and the name. Builds a label for notes
    // that is saved in local storage only, and set upon blur.
    let buildConLabel = (parent, name) => {
        const label = document.createElement("input");
        label.className = "smallItem span4 conLab";
        const curVal = localStorage.getItem(`${name}Label`);
        label.value = (curVal != null) ? curVal : "CUSTOM LABEL/NOTES HERE";
        label.onblur = () => localStorage.setItem(`${name}Label`, label.value);
        parent.appendChild(label);
    }

    // Requires container name, and the Read Only and Input objects. Builds
    // special container attributes that are name dependent as opposed to 
    // parameter dependent, meaning they do not have commands attached to them.
    let buildConSpecial = (name, ranges, RO, INP) => {
      
        if (name === "spec") { // Spectral display

            RO[`${name}Disp`] = new RObuild("div", null, // Primary
                ["smallItem", "span4"]); // Display for spec chart.

            RO[name] = new RObuild("div", "Spectral Info Display", 
                ["smallItem", "span4"]); // Primary display for info

        } else if (name.includes("re")) { // Relay displays

            RO[name] = new RObuild("div", `Plug #${Number(name[2])}`,
                ["smallItem", "span4"]); // Displays the relay number, Primary.

            RO[`${name}ConButtons`] = new RObuild("div", "", 
                ["smallItem", "span4", "con"]); // button display.

        } else if (name === "main") { // Main display

            // main RO is the time and time calibration. Alt is an alternate
            // that displays temp units and version. Avg displays clear average
            // time. Trends houses 3, 6, 9, and 12 hour trends.
            RO[name] = new RObuild("div", "0", ["smallItem", "span4"]);
            RO[`${name}Alt`] = new RObuild("div", "0", ["smallItem", "span4"]);
            RO[`${name}Avg`] = new RObuild("div", "0", ["smallItem", "span4"]);
            RO[`${name}Trends`] = new RObuild("div", null, 
                ["smallItem", "span4"]); 

            // Temperature units F or C. Uses hidden since range map is passed.
            INP[`${name}Units`] = new inputBuild(ranges.units, "input", "Units",
                true, ["smallItem"], null, ['F', 'C'], null, () => {
                const val = makeNum(`${name}UnitsHidden`);
                isCelcius = val ? true : false;
                handleMain(); handleTempHum();
            });

            INP[`${name}HrSet`] = new inputBuild(ranges.hour, "input",
                "Avg Clear Hours:", false, ["smallItem"], null, null, null, 
                null);

            INP[`${name}MinSet`] = new inputBuild(ranges.min, "input",
                "Avg Clear Minutes:", true, ["smallItem"], null, null, null, 
                () => {
                
                const cmd = convert("CLEAR_AVG_SET_TIME");
                const hr = makeNum(`${name}HrSet`);
                const min = makeNum(`${name}MinSet`);

                // Quality Checks.
                const QC1 = QC(hr, ranges.hour, `${name}HrSet`);
                const QC2 = QC(min, ranges.min, `${name}MinSet`);

                if (QC1 && QC2) {
                    let sendTime = (hr * 3600) + (min * 60);
                    sendTime = sendTime > 86340 ? 86340 : sendTime;

                    const ID = getID(defResp, {"avgClrTime": sendTime}, 
                        handleMain);

                    socket.send(`${cmd}/${sendTime}/${ID}`);
                }
            });

        } else if (name.includes("soil") || name.includes("light")) { // soil/lt
            RO[name] = new RObuild("div", "0", ["smallItem", "span4"]); // main

            // Used to show visual intensity bar.
            RO[`${name}ConIntensity`] = 
                new RObuild("div", "", ["smallItem", "span4"]);

        } else { // All other displays.
            RO[name] = new RObuild("div", "0", ["smallItem", "span4"]); 
        }
    }

    // Requires the object, its name, range, and both the read only and input
    // objects. Builds the relay number display, and its inputs for all 
    // all containers that require a relay attachment.
    let buildConRelay = (obj, name, ranges, RO, INP) => {
        RO[`${name}Re`] = new RObuild("div", "0", ["smallItem", "span4"]);

        INP[`${name}ReAtt`] = new inputBuild(ranges.re, "input", "Plug #", 
            true, ["smallItem"], `${name}Re`, ['0', '1', '2', '3', "NONE"], 
            {255: ["NONE", 4]}, () => {
                
            const cmd = convert(obj.cmd); 
            const reNum = makeNum(`${name}ReAttHidden`);

            // Updates the diplay using ESP32 protocol.
            const disp = (reNum == 4 ) ? RE_OFF : reNum;
            
            if (QC(reNum, ranges.re, `${name}ReAtt`)) {

                const ID = getID(defResp, {[`${name}Re`]: disp}, 
                    obj.callBack);

                // IAW ESP32 bitwise protocol, adjust value to send.
                let output = reNum & 0xF; // Set in the lower 4 bits.

                switch (name) {
                    // No action required or temp.
                    case "hum": output |= (1 << 4); break;
                    case "light": output |= (2 << 4); break;
                }

                socket.send(`${cmd}/${output}/${ID}`);
            }
        });
    }

    // Requires the object, its name, ranges, and both the read only and input
    // objects. Builds the relay set display, and its inputs for all containers
    // the require relays with less than greater than (LTGT) settings.
    let buildConRelaySet = (obj, name, ranges, RO, INP) => {
        INP[`${name}ReLTGT`] = new inputBuild(ranges.reCond, "input", 
            "Plug condition", false, ["smallItem"], `${name}ReCond`, 
            ["Less Than", "Gtr Than", "NONE"], null, null);

        INP[`${name}ReSetVal`] = new inputBuild(ranges.reSet, "input", 
            `Plug ${name} value`, true, ["smallItem"], `${name}ReVal`, null, 
            null, () => {
            
            const cond = makeNum(`${name}ReLTGTHidden`); // relay condition.
            const cmd = convert(obj.cmd); // Returns number.
            let val = makeNum(`${name}ReSetVal`);

            // If temperature, ensures that the value is in celcius and
            // multiplied by 100 IAW ESP requiremtns. This int value should
            // not exceed 327 degrees, which it never will.
            if (name === "temp") {  // Makes val an int with the fixed and mult.
                val = isCelcius ? val * 100 : 
                    (((val - 32) / 1.8).toFixed(2) * 100);
            }

            // Quality Checks
            const QC1 = QC(cond, ranges.reCond, `${name}ReLTGT`);
            const QC2 = QC(val, ranges.reSet, `${name}ReSetVal`, 
                name === "temp");

            if (QC1 && QC2) {
                const ID = getID(defResp, 
                    {[`${name}ReCond`]: cond, [`${name}ReVal`]: val}, 
                    obj.callBack);

                // IAW ESP32 bitwise protocol, adjust value to send. 
                let output = 0; // init to 0.

                switch (name) { // Soil has no relay.
                    case "temp": 
                    output |= (1 << 25); // 1 for temperature
                    output |= ((cond & 0b11) << 16); // 2 bit max.
                    output |= (val & 0xFFFF); // Ensure only lower 16-bits
                    break;

                    case "hum": // No sensor action req, passes 0.
                    output |= ((cond & 0b11) << 16); // 2 bit max.
                    output |= (val & 0xFFFF); // only lower 16-bits.
                    break;

                    case "light": 
                    output |= (1 << 28); // 1 for photoresistor
                    output |= ((cond & 0b11) << 24);
                    output |= (val & 0x0FFF); // Max is 4095
                    break;
                }

                socket.send(`${cmd}/${output}/${ID}`);  
            }
        });
    }

    // Requires the object, its name, ranges, and both the read only and input
    // objects. Builds the alert set display, and its inputs for all containers
    // the require alerts with less than greater than (LTGT) settings.
    let buildConAlertSet = (obj, name, ranges, RO, INP) => {
        RO[`${name}Alt`] = new RObuild("div", "0", ["smallItem", "span4"]);

        INP[`${name}AltLTGT`] = new inputBuild(ranges.altCond, "input", 
            "Alert condition", false, ["smallItem"], `${name}AltCond`, 
            ["Less Than", "Gtr Than", "NONE"], null, null);

        INP[`${name}AltSetVal`] = new inputBuild(ranges.altSet, "input", 
            `Alert ${name} value`, true, ["smallItem"], `${name}AltVal`, 
            null, null, () => {

            const cond = makeNum(`${name}AltLTGTHidden`); // alert cond.
            let val = makeNum(`${name}AltSetVal`);
            const cmd = convert(obj.cmd); // returns number.

            // If temperature, ensures that the value is in celcius and
            // multiplied by 100 IAW ESP requiremtns. This int value should
            // not exceed 327 degrees, which it never will.
            if (name === "temp") { 
                val = isCelcius ? val * 100 : 
                    (((val - 32) / 1.8).toFixed(2) * 100);
            }

            const QC1 = QC(cond, ranges.altCond, `${name}AltLTGT`)
            const QC2 = QC(val, ranges.altSet, `${name}AltSetVal`, 
                name === "temp");

            if (QC1 && QC2) {
                const ID = getID(defResp, 
                    {[`${name}AltCond`]: cond, [`${name}AltVal`]: val}, 
                    obj.callBack);

                // IAW ESP32 bitwise protocol, adjust value to send.
                let output = 0;

                if (name === "temp") {
                    output |= (1 << 25); // 1 for temperature.
                    output |= (1 << 24); // 1 for alert.
                    output |= ((cond & 0b11) << 16); // Condition
                    output |= (val & 0xFFFF); // Lower 16 bits is value.

                } else if (name === "hum") {
                    output |= (1 << 24); // 1 for alert.
                    output |= ((cond & 0b11) << 16); // Condition
                    output |= (val & 0xFFFF); // Lower 16 is value.

                } else if (name.includes("soil")) {
                    const sensNum = Number(name[4]); // Last char, soil(1)
                    output |= ((sensNum & 0xF) << 20); // Sensor number
                    output |= ((cond & 0b11) << 16); // Condition
                    output |= (val & 0xFFFF); // Lower 16 is value.
                }

                socket.send(`${cmd}/${output}/${ID}`);  
            }
        });
    }

    // Requires the object, its name, ranges, and both the read only and input
    // objects. Builds the dark set display, and its inputs for the light 
    // container so that it can adjust the setting at which positive light 
    // duration begins. If set to 500, duration starts until it falls below 500.
    let buildConDarkSet = (obj, name, ranges, RO, INP) => {
        RO[`${name}Dur`] = new RObuild("div", "0", ["smallItem", "span4"]);
        RO[`${name}Dark`] = new RObuild("div", "0", ["smallItem", "span4"]);

        INP[`${name}DarkSet`] = new inputBuild(ranges.darkSet, "input",
            "Dark value", true, ["smallItem"], "darkVal", null, null,
            () => {

            const cmd = convert(obj.cmd); // returns number value.
            const val = makeNum(`${name}DarkSet`);

            if (QC(val, ranges.darkSet, `${name}DarkSet`)) {
                const ID = getID(defResp, {"darkVal": val}, obj.callBack);
                let output = val & 0x00FFF000; // Nothing else req.
                socket.send(`${cmd}/${output}/${ID}`);
            }
            }
        );
    }

    // Requires the object, its name, ranges, and both the read only and input
    // objects. Specific to the spectral container, builds only the AGAIN and 
    // ASTEP inputs, using the container display for feedback.
    let buildConIntegrationSet = (obj, name, ranges, RO, INP) => {
        INP[`${name}Astep`] = new inputBuild(ranges.astep, "input",
            "Integration (step)", false, ["smallItem"], "astep", null,
            null, null
        );

        INP[`${name}Atime`] = new inputBuild(ranges.atime, "input",
            "Integration (time)", true, ["smallItem"], "atime", null,
            null, () => {

            const ASTEP = makeNum(`${name}Astep`);
            const ATIME = makeNum(`${name}Atime`);
            const cmd = convert(obj.cmd); // Returns number.

            // Quality checks.
            const QC1 = QC(ASTEP, ranges.astep, `${name}Astep`);
            const QC2 = QC(ATIME, ranges.atime, `${name}Atime`);

            if (QC1 && QC2) {

                const ID = getID(defResp, {"astep": ASTEP, "atime": ATIME}, 
                    obj.callBack);

                let output = ATIME & 0xFF; // Establish Atime on init.
                output |= ((ASTEP & 0xFFFF) << 8);
                socket.send(`${cmd}/${output}/${ID}`);
            }
            }
        );
    }

    // Requires the object, its name, ranges, and both the read only and input
    // objects. Specific to the spectral container, builds the gain input only,
    // with no display feature.
    let buildConGainSet = (obj, name, ranges, RO, INP) => {
        INP[`${name}Again`] = new inputBuild(ranges.again, "input",
            "Spectral Gain", true, ["smallItem"], "again", 
            ["0.5x", "1x", "2x", "4x", "8x", "16x", "32x", "64x", "128x",
                "256x", "512x"], null, () => {

            const AGAIN = makeNum(`${name}Again`);
            const cmd = convert(obj.cmd);

            if (QC(AGAIN, ranges.again, `${name}Again`)) {
                const ID = getID(defResp, {"again": AGAIN}, obj.callBack);
                socket.send(`${cmd}/${AGAIN}/${ID}`);
            }
            }
        );
    }

    // Requires the object, its name, ranges, and both the read only and input
    // objects. Builds the relay timer container with a status display, and 4 
    // inputs for on HH MM and off HH MM. 
    let buildConRelayTimerSet = (obj, name, ranges, RO, INP) => {
        RO[`${name}Stat`] = new RObuild("div", "0", ["smallItem", "span4"]);
        RO[`${name}Days`] = new RObuild("div", "0", ["smallItem", "span4"]);

        INP[`${name}HrSet`] = new inputBuild(ranges.reHour, "input",
            "On Time (HH MM):", false, ["smallItem"], null, null, null, 
            null);

        INP[`${name}MinSet`] = new inputBuild(ranges.reMin, "input",
            null, false, ["smallItem"], null, null, null, 
            null);

        INP[`${name}HrOff`] = new inputBuild(ranges.reHour, "input",
            "Off Time (HH MM):", false, ["smallItem"], null, null, null, 
            null);

        INP[`${name}MinOff`] = new inputBuild(ranges.reMin, "input",
            null, true, ["smallItem"], null, null, null, 
            () => {

            const cmd = convert(obj.cmd);
            const onHr = makeNum(`${name}HrSet`);
            const onMin = makeNum(`${name}MinSet`);
            const offHr = makeNum(`${name}HrOff`);
            const offMin = makeNum(`${name}MinOff`);

            // Quality checks. Due to 4, this is written like this to be clean.
            const QC1 = QC(onHr, ranges.reHour, `${name}HrSet`);
            const QC2 = QC(onMin, ranges.reMin, `${name}MinSet`);
            const QC3 = QC(offHr, ranges.reHour, `${name}HrOff`);
            const QC4 = QC(offMin, ranges.reMin, `${name}MinOff`);

            if (QC1 && QC2 && QC3 && QC4) {
                let output = 0;

                if (name.includes("re")) { // Ensures it is a relay.
                    const reNum = Number(name[2]); // Last char, relay(1).
                    const onTime = (onHr * 3600) + (onMin * 60);
                    const offTime = (offHr * 3600) + (offMin * 60);
                    let duration = (onTime < offTime) ? (offTime - onTime) :
                        (86400 - onTime + offTime);

                    duration = Math.floor(duration / 60); // sec to min integer.
                    let ID = -1; // Will change value depending on condition.

                    if (onTime === offTime) { // Signal to remove timer.
                        output |= ((99999 & 0x1FFFF) << 11); // bits 11-28
                        ID = getID(defResp, 
                            {[`re${reNum}TimerEn`]: 0, 
                                [`re${reNum}TimerOn`]: 99999,
                                [`re${reNum}TimerOff`]: 99999},
                            obj.callBack);

                    }  else {
                        output |= ((onTime & 0x1FFFF) << 11); // bits 11-28
                        ID = getID(defResp, 
                            {[`re${reNum}TimerEn`]: 1, 
                                [`re${reNum}TimerOn`]: onTime,
                                [`re${reNum}TimerOff`]: offTime},
                            obj.callBack);
                    }

                    output |= ((reNum & 0xF) << 28); // MSNibble
                    output |= (duration & 0x7FF); // bits 0 - 10
                    socket.send(`${cmd}/${output}/${ID}`); 
                }
            }
            }
        );
    }

    // After the container has been constructed using buildCon, it is passed 
    // here which will build the read only portion of each container.
    let buildRO = (container) => {

        const parent = container.parentID;

        // Iterates each read only key, creates and builds elements.
        Object.keys(container.readOnly).forEach(eleID => {
            const data = container.readOnly[eleID];
            const e = document.createElement(data.eleType);
            e.id = eleID;
            e.innerText = data.text
            data.classes.forEach(cls => { // add classes to list.
                if (cls == null || cls == undefined) return;
                e.classList.add(cls);
            });
            document.getElementById(parent).appendChild(e);
        });

        // Build the relay control buttons after RO is built.
        if (parent.includes("re")) {
            buildRelayButtons(container, parent[2]); // 3rd char.
        }

        if (parent.includes("soil")) {

            const bar = document.getElementById(`${parent}Intensity`);
            bar.style.position = "relative";
            
            bar.addEventListener("mousedown", (e) => {
                console.log("down");
                const xPos = e.clientX;
                const rect = bar.getBoundingClientRect();
                const relX = xPos - rect.left - (bar.offsetHeight / 2);
                const marker = document.createElement("div");
                marker.style.background = "yellow";
                marker.style.position = "absolute";
                marker.style.left = 0;
                marker.style.top = 0;
                const height = `${bar.offsetHeight - 4}px`; // -4 due to border.
                marker.style.height = height;
                marker.style.width = height;
                marker.style.left = relX + "px";
                bar.appendChild(marker);
            });



          


       

          

        }
    }

    // END CONTAINER BUILDING. =================================================
    // START SPECIAL DISPLAY BUILDING. =========================================

    // Builds the spectral display in the spectral container. Includes 8 
    // wavelengths in the visible light spectrum, as well as Near Infrared, and
    // Clear. 
    let buildSpec = () => { // spectral display in specCon.
        const disp = document.getElementById("spec"); // Primary display bar
        const parent = document.getElementById("specDisp");

        const fontColor = ["black", "white"]; // Used for color bars.

        // Event. requires color and element/color bar. Changes the main display
        // information based on color selected or moused over.
        let updDisp = (color, ele) => {
            disp.innerText = 
                `${color.toUpperCase()} | ${ele.value}/65535 counts | ` +
                `${(ele.value/655.35).toFixed(2)}%`;
        }

        // Iterate each color, using the COLORS object to build a graphical 
        // display of each wavelength.
        Object.keys(COLORS).forEach(color => {
            const e = document.createElement("div"); // Main element.
            const lab = document.createElement("div"); // Label
            e.style.backgroundColor = `${COLORS[color][1]}`;
            e.style.color = fontColor[COLORS[color][2]];
            lab.innerText = COLORS[color][0];
            e.id = color;

            // Add count and color data to display for click or mouseover .
            e.onclick = () => updDisp(color, e);
            e.onmouseover = () => updDisp(color, e);
            lab.onclick = () => updDisp(color, e); // E holds the data.
            lab.onmouseover = () => updDisp(color, e);
            parent.appendChild(lab);
            parent.appendChild(e);
        });

        // Creates buttons to display the current, averages, or previous 
        // averages to spectral display. Changes the global specDisplay var,
        // upon selection. 
        const buttons = {"Current": 'C', "Avgs": 'A', "Prev Avgs": 'P'};
        Object.keys(buttons).forEach(name => {
            const b = document.createElement("button");
            b.innerText = name;
            b.classList.add("span2");
            b.id = `${buttons[name]}Spec`;
            b.addEventListener("click", () => {
                specDisplay = buttons[name]; // Change global
                handleSpec(); // Update changes after setting.
            });
            parent.appendChild(b);
        });
    }

    // Builds the trends display in the main container. Displays 4 buttons to
    // select the amount of hours, that when clicked, fetches from the server.
    let buildTrends = () => {

        // Main container and buttons
        const parent = document.getElementById("mainTrends");
        parent.classList.add("trends");
        parent.classList.add("con");
        const buttons = ["3-hr", "6-hr", "9-hr", "12-hr"];
        const header = document.createElement("div");
        header.classList.add("span4");
        header.innerHTML = "<b>Trends</b>";
        header.style.textAlign = "center";
        parent.appendChild(header);

        buttons.forEach(but => {
            const b = document.createElement("button");
            b.id = `trend${but}`;
            b.value = Number(but.split('-')[0]); // either 3, 6, 9, or 12.
            b.innerText = but;
            b.onclick = () => getTrends(b.value);
            parent.appendChild(b);
        });

        // Trend text data will be set here. This preps for trend setting.
        const display = document.createElement("div");
        display.id = "trendDisp";
        display.className = "con span4 trends";
        parent.appendChild(display);
    }

    // Requires the container and relay number. Builds the relay buttons OFF,
    // ON, FORCE OFF, and FORCE RMV in each relay container. This allows manual
    // manipulation of each relay, vice it being attached to a sensor only.
    let buildRelayButtons = (container, reNum) => {
        const Labs = ["OFF", "ON", "FORCE OFF", "FORCE RMV"]; // Labels
        const parent = document.getElementById(`${container.parentID}Buttons`);
        const key = container.parentID.slice(0, 3); // first 3 chars, Ex re1.

        // Iterate each label and build button functionality.
        Labs.forEach((but, idx) => { 
            const b = document.createElement("button");
            b.innerText = but;
            b.id = `${container.parentID}But${idx}`; // Ex re0ConBut0 = OFF
            b.value = idx; // Index assigns the expected button value.

            // Special key assignment to the button to allow buttons to be 
            // disabled else where, if force off is selected, well until force
            // remove is selected.
            b.enabled = true;
        
            b.onclick = () => {
                if (!b.enabled) return; // Block if button is disabled.
                const cmd = convert("RELAY_CTRL");
                const ID = getID(defResp, {[`${key}`]: Number(b.value)}, 
                    handleRelays);

                let output = ((reNum & 0xF) << 4); // Set renum to init
                output |= (b.value & 0xF); // Set the control value.
                
                socket.send(`${cmd}/${output}/${ID}`);
            }

            parent.appendChild(b);
        });
    }

    // END SPECIAL DISPLAY BUILDING. ===========================================
    // START CONTAINER EXPANSION BUILDING. =====================================

    // Triggered by each containers expand button. Calls this function, passing
    // the container. This will build the user interactive portion.
    let expand = (container) => {
        const button = document.getElementById(container.buttonID);
        const inp = container.inputs;
        const ID = container.parentID;

        let append = (ele) => { // Appends to parent and appends to expansions.
            document.getElementById(ID).appendChild(ele);
            Expansions[ID].push(ele.id);
        }

        if (button.innerText === "Expand") {
            Expansions[ID] = []; // Clear before use.

            // Upon expand, if relay, include special day select buttons
            // appended before hh mm settings or any other input settings. This
            // exists due to special non-cookie cutter circumstances.
            if (container.parentID.includes("re")) {
                const days = expandRelayDays(container); // day selection.
                append(days);
            }

            // Iterate each input element, building the label, input element,
            // button, and hidden input... if required.
            Object.keys(inp).forEach(ele => {
                const data = inp[ele];
                const label = expandLabel(ele, data); // Null if no label.
                const einp = expandInput(ele, data, container.parentID);
                const but = data.incBut ? expandButton(ele, data) : null;

                // Build hidden carrier input if range map attached. This 
                // allows separation of real values and display values.
                const hidden = data.rangeMap ? expandHidden(ele, data) : null;

                // Append all newly created elements to the parent container.
                if (label) append(label);
                append(einp);
                if (hidden != null) append(hidden);
                if (but != null) append(but); // append last.
        
                data.classes.forEach(cls => { // Add classes
                    if (cls == null || cls == undefined) return; // none
                    einp.classList.add(cls);
                });

                // input listeners will link the adjustment bar with the 
                // input box for dynamic value display.
                if (data.eleType === "input") {
                    expandListener(einp, hidden, ID, data);
                }
            });

            // For input adjustment tools.
            const adj = document.createElement("div");
            adj.innerText = "Adjustments";
            adj.id = `${ID}Adj`;
            adj.className = "span4 smallItem con";
            append(adj);

            button.innerText = "Contract"; // acts as a toggle and display.

        } else if (button.innerText === "Contract") { 

            // Iterates the containers expansion IDs, and removes each one.
            Expansions[ID].forEach(id => document.getElementById(id).remove());
            button.innerText = "Expand";

            // Special rules to default the display to a set string.
            if (container.parentID === "specCon") { 
                const integ = document.getElementById("spec");
                integ.innerText = "Spectral Info Display";
                integ.classList.remove("selected");
            }
        }
    }

    // Requires relay container. Creates a button display before inputs with
    // each day name. Sets the reDays global to the current selected days 
    // which will be used to send a socket command with the days the relay timer
    // is enabled. 
    let expandRelayDays = (container) => {
        const butDisp = document.createElement("div");
        butDisp.className = "con span4";
        const reNum = container.parentID[2]; // Relay number extraction.
        const dayVal = Number(allData[`re${reNum}Days`]); // relay days value.
        butDisp.id = `${container.parentID}Days`;

        reDays[reNum] = 0; // Clear global before setting.

        DAYS.forEach((day, idx) => {
            const but = document.createElement("button");
            but.id = `${container.parentID}${day}`;
            but.value = 1 << idx; // bitwise sets the correct value.
            but.innerText = day;

            // Ensure proper selection upon expansion. The button attribute is
            // in addition to ensure proper toggle.
            let isSel = (dayVal >> idx) & 0b1;
            if (isSel) {
                but.isSel = true;
                but.classList.add("selected");
                reDays[reNum] += Number(but.value); // Sum all selected days.

            } else {
                but.isSel = false;
                but.classList.remove("selected");
            }

            // Adjust the global relayDays upon changing values.
            but.onclick = () => {
                if (but.isSel) {
                    reDays[reNum] -= Number(but.value);
                    but.isSel = false;
                    but.classList.remove("selected");

                } else {
                    reDays[reNum] += Number(but.value);
                    but.isSel = true;
                    but.classList.add("selected");
                }
            }
            
            butDisp.appendChild(but);
        });

        // Submits the bitwise value along with the relay number.
        const submit = document.createElement("button");
        submit.id = `${container.parentID}DaySubmit`;
        submit.className = "span4";
        submit.innerText = "Submit Timer Days";
        submit.onclick = () => {
            const cmd = convert("RELAY_TIMER_DAY");
            const ID = getID(defResp, {[`re${reNum}Days`]: reDays[reNum]},
                handleRelays);

            let output = (reNum & 0xF) << 8; // Init with relay number.
            output |= (reDays[reNum] & 0x7F); // 7 bits only, 1 for each day.
 
            socket.send(`${cmd}/${output}/${ID}`);
        }

        butDisp.appendChild(submit);

        return butDisp;
    }

    // Builds the input labels for each input requiring the input ID, and its
    // associated data.
    let expandLabel = (inpID, data) => {
        if (!data.label) return null; // Prevents label if not set.
        const label = document.createElement("div");
        label.style.gridColumn = "1 / 3"; // Span 2 if regular inp
        label.innerText = data.label; 
        label.style.alignContent = "center"; // Keep inline with input boxes.
        label.id = `${inpID}Lab`;
        return label;
    }

    // Requires the input ID, its corresponding data, and the container ID. 
    // Input will always be displayed. If a range map is sent, this will turn 
    // the input into display only, and a hidden input will be built and 
    // populated with a numerical value. If no map is sent, serves as both an
    // input and display.
    let expandInput = (inpID, data, contID) => {
        const ele = document.createElement(data.eleType);
        ele.id = inpID; 
        let val = allData[data.dataPtr]; // set upon init

        // No pointer/key to the JSON key/val data. Handles special cases 
        // with no data pointer. This is a special manipulator that changes val.
        if (!data.dataPtr) { 

            if (inpID.includes("re")) { // Check if it is a relay.
               
                const reTag = inpID.slice(0, 3); // Will extract reN.
            
                if (allData[`${reTag}TimerEn`]) { // check for enabled
                    const rest = inpID.slice(3, inpID.length); // Remaining str

                    // Gets times in seconds
                    const onTime = allData[`${reTag}TimerOn`];
                    const offTime = allData[`${reTag}TimerOff`];

                    switch (rest) { // Sets the value to the appropriate value.
                        case "HrSet": val = timeStr(onTime, true)[0]; break;
                        case "MinSet": val = timeStr(onTime, true)[1]; break;
                        case "HrOff": val = timeStr(offTime, true)[0]; break;
                        case "MinOff": val = timeStr(offTime, true)[1]; break;
                    }

                } else {
                    val = 0; // zero out if not enabled.
                } 

            } else if (inpID === "mainUnits") {
                val = Number(isCelcius);

            } else if (inpID === "mainHrSet") {
                val = timeStr(allData["avgClrTime"], true)[0]; // Hr

            } else if (inpID === "mainMinSet") {
                val = timeStr(allData["avgClrTime"], true)[1]; // Min
            }
        }

        if (data.rangeMap) { // Checks for rangeMap. If true...
            ele.readOnly = true; // Forces use of adjustment bar.

            // Checks for a special map and that the range map value does not
            // eixst. If true, sets to special map, if false, uses range map/
            if (data.specMap && !data.rangeMap[val]) {
                ele.value = data.specMap[val][0];
            } else {
                ele.value = data.rangeMap[val];
            }

        } else {

            ele.readOnly = false; // Allows use of input or adj bar.

            // ESP rules dictate that temp is passed in C multiplied by 100 for
            // float point precision. 
            if (contID === "tempCon") {
                ele.value = isCelcius ? Number(val / 100).toFixed(1) :
                    Number(((val / 100) * 1.8) + 32).toFixed(1);
            } else {
                ele.value = val;
            }
        }

        return ele;
    }

    // Stores the actual numerical values if a range map is passed along with
    // an input.
    let expandHidden = (inpID, data) => { 
        const actual = document.createElement(data.eleType);
        actual.type = "hidden";
        actual.id = `${inpID}Hidden`;

        let val = Number(allData[data.dataPtr]); // Set upon init.

        // Check if part of the special map first. Iterate each key, and if
        // matched, updates the value with req value. Special maps are used 
        // only for data outside the range scope, no range map required here.
        if (data.specMap) {
            Object.keys(data.specMap).forEach(key => {
                if (key == val) val = data.specMap[allData[data.dataPtr]][1];
            });
        }

        // Manipulate based on special data.
        if (inpID === "mainUnits") val = Number(isCelcius);

        actual.value = val; // Set the value after checks complete.
        return actual;
    }

    // builds submit button for selected input items. Requires input ID and its 
    // corresponding data. 
    let expandButton = (inpID, data) => {
        const button = document.createElement("button");
        const isRelay = inpID.includes("re");
        const reText = "Submit Time (hold to disable timer)"; // if isRelay
        button.id = `${inpID}But`;
        
        // Timeout stuff is used only for the relay timer button.
        let holdTimeout = 0; // Will be assigned to a timeout.

        // Assigns a timeout to holdTimeout. If hold complete for 1 sec,
        // zeros all values and submits, which will trigger a disable timer.
        let startHold = () => { 
            holdTimeout = setTimeout(() => {
                const tag = inpID.slice(0, 3); // Ex re1, re2, etc...
                document.getElementById(`${tag}HrSet`).value = 0;
                document.getElementById(`${tag}MinSet`).value = 0;
                document.getElementById(`${tag}HrOff`).value = 0;
                document.getElementById(`${tag}MinOff`).value = 0;
                button.innerText = "RELEASE"; // Prompts release to submit.
                button.classList.add("warning"); // changes color.
            }, 1000);
        }
        
        let endHold = () => { // Releases timeout.
            clearTimeout(holdTimeout);
            button.innerText = reText;
            button.classList.remove("warning");
        }

        button.innerText = isRelay ? reText : "Submit";
        button.onclick = () => data.butFunc();

        // returns button, only relays get the additional event listeners.
        if (!inpID.includes("re")) return button; 
        button.classList.add("span4");
        button.addEventListener("mousedown", startHold);
        button.addEventListener("mouseup", endHold);
        button.addEventListener("touchstart", startHold);
        button.addEventListener("touchend", endHold);
        return button;
    }

    // Event listener exclusive to the all inputs in the container. Requires 
    // input, the hidden input, the parent container ID, and the associated
    // input data. Adds event listener to inputs to allow adjustment bar use.
    let expandListener = (input, hidden, parent, data) => {

        // The adjusted value is passed and the display value will be adjusted
        // as well as the hidden (actual) value if a range map is passed.
        let adjVals = (adjVal) => { 

            if (hidden) (hidden.value = adjVal); // Actual numerical value.

            // Adjust the display value using the range map or the adj value.
            input.value = (data.rangeMap === null) ? 
                adjVal : data.rangeMap[adjVal];

            // Allow display of integration time when adjusting values.
            if (parent === "specCon") { 
                const ASTEP = makeNum("specAstep");
                const ATIME = makeNum("specAtime");
                const AGAIN = makeNum("specAgain");
                const DISP = document.getElementById("spec"); // main element

                // Integration time is computed as per the AS7341 datasheet.
                const intTime = (ASTEP + 1) * (ATIME + 1) * 0.00278;

                DISP.innerText = `Integration Time: ${intTime.toFixed(1)} ms`;
                DISP.classList.add("selected");
            }
        }
        
        // When an input is focused, It takes ownership of the adjustment bar.
        input.addEventListener("focus", () => {

            let {min, max, step} = data.ranges; // Set vars.
            
            // If F is set instead of C, adjusts the min, max, and step.
            if (["tempReVal", "tempAltVal"].includes(data.dataPtr) &&
                !isCelcius) { 
                min = (min * 1.8) + 32;
                max = (max * 1.8) + 32;
                step = 1; // smaller step size only for celcius.
            }

            // On focus, adds an adjustment bar.
            const adj = document.getElementById(`${parent}Adj`);
            adj.innerHTML = `<input id="${parent}AdjBar" type="range" ` + 
                `class="span4" width="300px min="${min}" max="${max}" ` +
                `step="${step}">`;
            
            const AdjBar = document.getElementById(`${parent}AdjBar`);
            AdjBar.addEventListener("input", () => adjVals(AdjBar.value));

            // Specify params for buttons. These buttons increase the 
            // adjustment granularity to assist the adjustment bar.
            ['-', '+'].forEach(label => { 
                const but = document.createElement("button");
                but.classList.add("span2");
                but.id = `${parent}${label}`; // Should be like tempCon+
                but.innerHTML = `<b>${label} ${step}</b>`;
                adj.appendChild(but);

                // Event listener directly controls the adjbar, which then 
                // Adjusts the box value.
                but.addEventListener("click", () => {
                    if (label === '+') {
                        AdjBar.value = Number(AdjBar.value) + Number(step);
                    } else {
                        AdjBar.value = Number(AdjBar.value) - Number(step);
                    }
                    
                    adjVals(AdjBar.value);
                });
            });

            // Set the adjBar value upon linking it to an input. If range map
            // is included, defaults to the hidden value, if not, uses input.
            AdjBar.value = (data.rangeMap) ? hidden.value : input.value;

            // Specmap omitted, not required. Specmap used only when converting
            // ESP JSON to cliently friendly format.

            input.classList.add("selected");
        });

        input.addEventListener("blur", () => {
            input.classList.remove("selected");
        });
    }

    // END CONTAINER EXPANSION BUILDING. =======================================
    // START CONTAINER SUPPLEMENTARY FUNCTIONS. ================================

    let makeNum = (ID) => { // Used to ref ID, and return Number of the value.
        return Number(document.getElementById(ID).value);
    }

    // Requires the value, its ranges, the input ID, and if it is a temperature
    // reading. Upon success, changes input BG to match, and same with failure,
    // which also prompts an alert. 
    let QC = (val, ranges, inpID, isTemp = false) => {
        const ele = document.getElementById(inpID);

        // If temperature, div by 100 IAW ESP temperature protocol. This is 
        // because temperature val will by mult by 100 before sending.
        val = isTemp ? val / 100 : val; 

        if (val >= ranges.min && val <= ranges.max) {
            ele.classList.remove("badRange")
            ele.style.backgroundColor = "rgb(0, 224, 27)";
            return true;

        } else {
            ele.classList.add("badRange");

            if (isTemp && !isCelcius) { // Applies to faren value only.
                window.alert(`${((val * 1.8) + 32).toFixed(1)} out of range ` +
                    `${((ranges.min * 1.8) + 32).toFixed(1)} to ` +
                    `${((ranges.max * 1.8) + 32).toFixed(1)}`);

            } else { // All other alerts.
                window.alert(`${val} out of range ${ranges.min} to ` +
                    `${ranges.max}`);
            }

            return false;
        }
    }

    let timeStr = (seconds, returnRaw = false) => {
        const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
        const s = (seconds % 60).toString().padStart(2, '0');
        return (returnRaw) ? [h, m, s]: `${h}:${m}:${s}`;
    }

    // Returns the index of the command, this is used with esp32 ssocket
    // command as argument 1.
    const convert = (CMD) => Number(CMDS.indexOf(CMD));

    // Requires callback function for a successful update, the key/value
    // pairs with the key being the allData JSON key, and its value to
    // update to, and the second callback function which will run after
    // the JSON has been updated, to update the display. Returns the ID.
    const getID = (callback1 = null, KVs = null, callback2 = null) => {
        const id = idNum++;
        requestIDs[id] = [callback1, KVs, callback2]; 
        idNum = (idNum >= maxID) ? 0 : idNum; // Reset to 0 if == max.
        return id;
    }

    // END CONTAINER SUPPLEMENTARY FUNCTIONS. ==================================
    // START SOCKET HANDLERS. ==================================================

    // No params. Returns true if socket is open, false if not.
    const isSocketOpen = () => (Flags.SKTconn && WebSocket.OPEN);

    // SOCKETS. Event handlers.
    const initWebSocket = () => {
        console.log("Init websocket");
        socket = new WebSocket(webSktURL); // Open new socket.
        socket.onopen = socketOpen; // Set the event handler functions.
        socket.onclose = socketClose;
        socket.onmessage = socketMsg;
    }

    const socketOpen = () => { // Open socket handler
        console.log("Connected to server");
        Flags.SKTconn = true;
        poll = setInterval(pollServer, POLL_INTV); // Set intervals
        clearReqID = setInterval(clearOldRequests, 10000);
    }

    const socketClose = () => { // Close socket handler
        console.log("Disconnected from server");
        Flags.SKTconn = false;
        clearInterval(poll); // Clear intervals.
        clearInterval(clearReqID);
        setTimeout(initWebSocket, 2000); // Attempt reconnect.
    }

    // Messages from server will be in JSON format, parsed, and sent to the
    // assigned function to handle that response.
    const socketMsg = (event) => handleResponse(JSON.parse(event.data)); 

    // END SOCKET HANDLERS. ====================================================

    // Receives the parsed JSON response from the socket message. Gets its
    // function from the ID, runs the function passing the response, and
    // deletes the ID signifying the request is complete.
    const handleResponse = (response) => {
        const func = requestIDs[response.id][0]; // callback function
    
        // Check if default response. If so, will send the html element
        // ID and the value to set it to iff successful. This will handle
        // most socket responses.
        if (func === defResp && response.status === 1) { // 1 = success
            func(requestIDs[response.id][1], requestIDs[response.id][2]);
        } else if (func != null) { 
            func(response); // Used moreso for trends and get all.
        }

        delete requestIDs[response.id]; // Delete corresponding ID.
    }

    // Polls the server at a set interval requesting all data.
    const pollServer = () => {
        if (isSocketOpen()) {
            socket.send(`${convert("GET_ALL")}/${0x00}/${getID(getAll)}`);
        }
    }

    // Clears requests that will not be satisfied by the server to 
    // prevent the from accumulating to non responses.
    const clearOldRequests = () => {
        Object.keys(requestIDs).forEach(id => {
            if (Number(id) < (idNum - 3)) delete requestIDs[id];
        });
    }

    // Gets the log, separates it into a non-delimited array, to be used
    // for diplay.
    let getLog = () => { // HTTP call
        const button = document.getElementById("logBut");
        fetch(logURL)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error status: ${response.status}`);
            }
            return response.text(); // If no err, proceed.
        })
        .then(text => {
            if (text.length <= 0) throw new Error("No Log Data");
            log = text.split(logDelim); // Split by delim into array.
            button.style.backgroundColor = "green"; // Shows new log

            // Is a receipt only, Allows server to remove flag.
            if (!isSocketOpen()) return; // Block
            socket.send(`${convert("NEW_LOG_RCVD")}/${0x00}/${getID()}`); 
        })
        .catch(err => console.log(err));
    }

    const openLog = () => { // Opens the log for display.
        const button = document.getElementById("logBut");
        const logDisp = document.getElementById("log");

        if (Flags.openLog) {
            let html = "";
            log.forEach(entry => html += `${entry}<br>`);
            logDisp.innerHTML = html;
            button.innerText = "Close log";
            Flags.openLog = false;

        } else if (!Flags.openLog) {
            logDisp.innerText = ""; // Clear out.
            button.style.backgroundColor = "black";
            button.innerText = "Open log";
            Flags.openLog = true;
        }
    }

    // Qty 1 - 12. Default to 6. Gets the previous n hours of temp/hum or
    // light trends.
    let getTrends = (qty = 6) => {
        if (!isSocketOpen()) return; // Block
        qty = (qty < 1 || qty > 12) ? 6 : qty; // Ensure within bounds, def set.
        socket.send(`${convert("GET_TRENDS")}/${qty}/${getID(setTrends)}`); 
    }

    // Pass the current time in seconds from the ESP. If different than
    // real time, sends socket cmd to calibrate to real time.
    let calibrateTime = (seconds) => { // calibrates time if different
        const time = new Date();
        const padding = 2; // This prevents constant cal w/ rounding err.
        let secPastMid = (time.getHours() * 3600) + (time.getMinutes() * 60) 
            + time.getSeconds();

        // Compute time delta between machine and client.
        const delta = ((seconds - secPastMid)**2)**(1/2);

        // calibrate clock if esp time out of range. Ignore midnight switch.
        if (delta >= padding && secPastMid != 0) { 
            if (!isSocketOpen()) return; // Block
            socket.send(`${convert("CALIBRATE_TIME")}/
            ${secPastMid}/${getID(defResp)}`);
        }
    }

    // requires the intensity bar ID, the current value, the max value, the
    // starting color, and ending color. Colors the gradient background to show
    // graphical proportionality of value compared to its max.
    let intensityBar = (barID, val, max, clr1, clr2) => {
        const bar = document.getElementById(barID);
        const barWidth = bar.offsetWidth;
        const pxStop = Number(val) / Number(max) * Number(barWidth);

        bar.style.background = `linear-gradient(to right, 
            ${clr1} 0px, ${clr1} ${pxStop}px, 
            ${clr2} ${pxStop}px, ${clr2} ${barWidth}px)`; 
    }

    let handleMain = () => {

        const units = ['F', 'C']; // Used for unit display.
        const isCal = ['N', 'Y']; // Used for is time calibrated display.

        document.getElementById("main").innerText = 
            `Time: ${timeStr(allData["sysTime"])} | Calibrated: ` +
            `${isCal[allData["timeCalib"]]}`;

        document.getElementById("mainAlt").innerText = `Temp Units: ` +
            `${units[Number(isCelcius)]} | Version: ${allData["firmv"]}`;

        document.getElementById("mainAvg").innerText = 
            `Clear Avgs @ ${timeStr(allData["avgClrTime"])}`;
    }

    let handleTempHum = () => { // Handles temperature and humidity container.

        // Checks the bounds, and if the temp/hum is out of bounds, adds class.
        let checkBounds = (data, eleReID, eleAltID) => {

            // Check that relay is in play and its has a value.
            if (data[3] != RE_OFF) { 
                // If true, check that the relay has a setting other than NONE.
                if (((data[4] == 0) && (data[0] < data[5])) ||
                    ((data[4] == 1) && (data[0] > data[5]))) {

                    eleReID.classList.add("boundBust");
                } else {
                    eleReID.classList.remove("boundBust");
                }

            } else {
                eleReID.classList.remove("boundBust");
            }

            // Next check that the alert has a setting other than NONE.
            if (((data[6] == 0) && (data[0] < data[7])) ||
                ((data[6] == 1) && (data[0] > data[7]))) {

                    eleAltID.classList.add("boundBust");
                } else {
                    eleAltID.classList.remove("boundBust");
                }
        }

        // Processes data from the allData object, to display the current
        // settings and values in the RO portion of the tempcon.
        let proc = (cont, data, name) => {
            
            const parent = document.getElementById(cont.parentID);
            const IDs = Object.keys(cont.readOnly);
            const val = document.getElementById(IDs[0]);
            const re = document.getElementById(IDs[1]);
            const alt = document.getElementById(IDs[2]);
            const U = isCelcius ? ' C' : ' F';

            // Append units onto name.
            name = (name === "Temp") ? name += U : name += ' %';

            // Set the text for the RO portions of the tempcon.
            val.innerText = `${name}: ${data[0].toFixed(1)} |` +
                ` Avg: ${data[1].toFixed(1)} |` +
                ` Prev Avg: ${data[2].toFixed(1)}`;

            re.innerText = `Plug: ${relayNum(data[3])} set to` +
                ` ${reAltCond(data[4], data[5])}`;
            
            alt.innerText = `Alert set to ${reAltCond(data[6], data[7])}`;

            parent.style.backgroundColor = sensUpBg[allData["SHTUp"]];
            // Check bounds once processed to ensure correct coloring.
            checkBounds(data, re, alt);
        }

        // changes the temperature to the correct float value.
        let manipTemp = (data) => { // Do not affect standing values.
            data[5] /= 100; // reduce int to float
            data[7] /= 100; // reduce int to float
            const prohibIdx = [3, 4, 6]; // Ignore these indicies in loop.

            if (!isCelcius) {

                data.forEach((item, idx) => {
                    if (prohibIdx.indexOf(idx) != -1) return; // match
                    data[idx] = ((item * 1.8) + 32); // Conv to F.   
                });
            }
        }

        // array with all the temperature data to process.
        let data = [allData.temp, allData.tempAvg, allData.tempAvgPrev,
            allData.tempRe, allData.tempReCond, allData.tempReVal,
            allData.tempAltCond, allData.tempAltVal];

        manipTemp(data);
        proc(tempCon, data, "Temp");

        // update array with the humidity data to process.
        data = [allData.hum, allData.humAvg, allData.humAvgPrev,
            allData.humRe, allData.humReCond, allData.humReVal,
            allData.humAltCond, allData.humAltVal];

        proc(humCon, data, "Hum"); 
    }

    let handleSoil = () => { // Handles all soil containers.
        const cont = [soil1Con, soil2Con, soil3Con, soil4Con]; // estab cont.

        // Changes RO display color if value exceeds bounds.
        let checkBounds = (data, eleAltID) => {
            if (((data[1] == 0) && (data[0] < data[2])) ||
                ((data[1] == 1) && (data[0] > data[2]))) {

                eleAltID.classList.add("boundBust");
            } else {
                eleAltID.classList.remove("boundBust");
            }
        }

        // processes data from the allData object, to diplay the current setting
        // and values in the RO portion of each soilCon.
        let proc = (cont, data, name) => {
            const parent = document.getElementById(cont.parentID);
            const IDs = Object.keys(cont.readOnly);
            const val = document.getElementById(IDs[0]); // main
            const alt = document.getElementById(IDs[2]); // alert display

            intensityBar(IDs[1], data[0], 4095, "red", "black");
            val.innerText = `${name.slice(0, 4)} #${name[4]}: ${data[0]}`;
            alt.innerText = `Alert set to ${reAltCond(data[1], data[2])}`;

            parent.style.backgroundColor = sensUpBg[allData[`${name}Up`]];
            checkBounds(data, alt);
        }

        cont.forEach((sensor, idx) => {
            let data = [allData[`soil${idx}`], 
                allData[`soil${idx}AltCond`], allData[`soil${idx}AltVal`]];

            proc(sensor, data, `soil${idx}`);
        });
    }

    let handlePhoto = () => {
        
        let checkBounds = (data, eleReID, darkID, durID) => {
            // Check the relay is in play nad has a value.
            if (data[3] != RE_OFF) {
                if (((data[4] == 0) && (data[0] < data[5])) || 
                    ((data[4] == 1) && (data[0] > data[5]))) {

                    eleReID.classList.add("boundBust");
                } else {
                    eleReID.classList.remove("boundBust");
                }
            }

            if (data[0] < data[7]) {
                darkID.classList.add("dark");
                durID.classList.add("dark");
            } else {
                darkID.classList.remove("dark");
                durID.classList.remove("dark");
            }
        } 

        let proc = (cont, data, name) => {
            const parent = document.getElementById(cont.parentID);
            const IDs = Object.keys(cont.readOnly);
            const val = document.getElementById(IDs[0]); // main
            const re = document.getElementById(IDs[2]); // relay info
            const dur = document.getElementById(IDs[3]); // duraiton info
            const dark = document.getElementById(IDs[4]) // dark info
            const barWidth = intensityBar.offsetWidth; // inten bar width
            const pxStop = Number(data[0]) / 4095 * Number(barWidth);

            intensityBar(IDs[1], data[0], 4095, "red", "black");
           
            val.innerText = `${name}: ${data[0]} | Avg: ${data[1].toFixed(1)}` +
                ` | Prev Avg: ${data[2].toFixed(1)}`;

            re.innerText = `Plug: ${relayNum(data[3])} set to` +
                ` ${reAltCond(data[4], data[5])}`;

            dur.innerText = `Light duration: ${timeStr(data[6])}`;
            dark.innerText = `Dark val set to ${data[7]}`;

            parent.style.backgroundColor = sensUpBg[allData.photoUp];
            checkBounds(data, re, dark, dur);
        }

        const data = [allData.photo, allData.photoAvg, allData.photoAvgPrev,
            allData.lightRe, allData.lightReCond, allData.lightReVal,
            allData.lightDur, allData.darkVal];

        proc(lightCon, data, "Light");
    }

    let handleSpec = () => {
        const specButtonIDs = ["CSpec", "ASpec", "PSpec"];
        const specMap = {'C': "", 'A': "Avg", 'P': "AvgPrev"}; // For JSON key

        specButtonIDs.forEach(ID => {
            const e = document.getElementById(ID);
            if (ID[0] === specDisplay) { // first char
                e.classList.add("selected");
            } else {
                e.classList.remove("selected");
            }
        });

        let counts = {}; // Used to gather all counts for comparison.
        let maxCt = 1;
        let maxClr = null;

        // Iterate to append counts with each color count. Depending on the
        // selected current, avg, or prev avg, the specMap is used to append 
        // the color with the right json key, with the counts being the value.
        Object.keys(COLORS).forEach(color => {
            const ctVal = allData[`${color}${specMap[specDisplay]}`];
            counts[color] = ctVal;

            // Set max count, and ignore clear, since its height will skew data.
            // Set color to the one with the highest value.
            maxClr = ((ctVal > maxCt) && (color != "clear")) ? color : maxClr;
            maxCt = ((ctVal > maxCt) && (color != "clear")) ? ctVal : maxCt;
            
        });

        const ctPerPix = maxCt / MAX_SPEC_PX; // Counts per pixel.

        // Iterates the counts and assigns a pixed value to each. The highest
        // val will be at ~300 px, and the rest will be relative.
        Object.keys(counts).forEach(color => {
            const bar = document.getElementById(color);
            bar.value = counts[color];
            let width = Math.floor(counts[color] / ctPerPix); // Initial width

            // Set width not to exceed max.
            width = width > MAX_SPEC_PX ? MAX_SPEC_PX : width; 

            // Displays the count value in the largest bar as a reference for
            // the others.
            if (color === maxClr || color === "clear") { // d
                document.getElementById(color).innerText = 
                    `${(counts[color] / 655.35).toFixed(2)}% of Max`;
            } else { // Remove text from rest.
                document.getElementById(color).innerText = "";
            }

            bar.style.width = `${width}px`;
        });

        document.getElementById("specCon").style.backgroundColor =
            sensUpBg[allData.specUp];
    }

    const handleRelays = () => {
        const cont = [re1Con, re2Con, re3Con, re4Con]; // containers
        
        // Ensure the same naming convention as buildRelayButtons().
        cont.forEach((re, idx) => {

            // Button stuff. Used to handle the force off function primarily.
            const reVal = Number(allData[`re${idx}`]);
            const dayVal = Number(allData[`re${idx}Days`]);
            const off = document.getElementById(`re${idx}ConBut0`);
            const on = document.getElementById(`re${idx}ConBut1`);
            const forceOff = document.getElementById(`re${idx}ConBut2`);
            const forceRem = document.getElementById(`re${idx}ConBut3`);
            const days = document.getElementById(`re${idx}Days`);

            // Set the RO display to show days set.
            let dayStr = "Days: ";

            for (let i = 0; i < 7; i++) { // Bitwise settings to extract day.
                const isSet = (dayVal >> i) & 0b1;
                if (isSet) dayStr += `${DAYS[i]} | `;
            }

            dayStr = dayStr.slice(0, dayStr.length - 3); // Del trailing delim.
            days.innerText = dayStr;

            if (reVal === 2) { // Force off, disable all except force remove.
                off.enabled = false;
                on.enabled = false;
                forceOff.enabled = false;
                
                if (!forceRem.interval) { // Flash indicating must be clicked.
                    forceRem.interval = setInterval(() => {
                        forceRem.classList.toggle("blinker");
                    }, 500);
                }

            } else if (reVal === 3) { // Force removed, all reenabled.
                off.enabled = true;
                on.enabled = true;
                forceOff.enabled = true;
                if (forceRem.interval) { // If interval, remove it.
                    clearInterval(forceRem.interval);
                    forceRem.classList.remove("blinker"); // Remove if set.
                }
            }

            for (let i = 0; i < 4; i++) { // Iterate through each button
                const but = document.getElementById(`re${idx}ConBut${i}`);

                if (reVal === i) {
                    but.classList.add("selected");
                } else {
                    but.classList.remove("selected");
                }
            }

            const IDs = Object.keys(re.readOnly);
            const RO = document.getElementById(IDs[2]); // 3rd RO box.
            const reTmrEn = allData[`re${idx}TimerEn`];
            const reTmrOn = allData[`re${idx}TimerOn`];
            const reTmrOff = allData[`re${idx}TimerOff`];

            if (reTmrEn) {
                RO.innerText = `Timer set from ${timeStr(reTmrOn)} to ` +
                    `${timeStr(reTmrOff)}`;
            } else {
                RO.innerText = `Timer Disabled`;
            }
        });
    }

    // RECEIVED MESSAGE HANDLERS

    // Once all data is req in polling, calls this with reply.
    let getAll = (data) => { // Sets the addData object to response
        allData = data; // Allows use between poll interval waits
        
        const title = document.getElementById("title");
        title.innerHTML = `MysteryGraph Greenhouse`;

        calibrateTime(data.sysTime); // Ensures sys clock is calib to client
        handleMain(); handleTempHum(); handleSoil(); handlePhoto();
        handleSpec(); handleRelays();

        if (data.newLog === 1) getLog(); // Gets log if avail
    }

    // Requires the html element ID, and value to update it to. Only runs
    // upon a successful esp-32 change indicated in socket reply. Changes
    // innerHTML in the event the value is HTML.
    let defResp = (KVs = null, CBfunc = null) => { // Default response.
        if (KVs) Object.keys(KVs).forEach(key => allData[key] = KVs[key]);
        if (CBfunc) CBfunc(); 
    };

    // Set the trends when received back from socker server.
    let setTrends = (data) => {
        const parent = document.getElementById("trendDisp");
        parent.innerText = ""; // Clear out before populating.
        const mainLab = document.createElement("div"); // main label.
        mainLab.classList.add("span4");
        mainLab.innerHTML = `<b><- - - Newer --- Older - - -></b><br>` +
            `Spectral data is out of 65535`;
        mainLab.style.textAlign = "center";
        parent.appendChild(mainLab);

        Object.keys(data).forEach(key => {
            if (key === "id") return; // Skip AKA continue. Omit this kv pair.
            const lab = document.createElement("div");
            const content = document.createElement("div");
            lab.innerHTML = `<b>${key}</b>`;
            lab.style.textAlign = "center";
            lab.classList.add("span4");
            content.classList.add("span4");
            parent.appendChild(lab);
            parent.appendChild(content);

            let str = "";
            data[key].forEach((val, idx)=> {
                str += `[${val}] , `;
            });

            str = str.slice(0, str.length - 3); // Removes comma and whitespace.
            content.innerText = str;
        });

        let close = document.createElement("button");
        close.innerText = "Close Trends";
        close.classList.add("span4");
        close.onclick = () => parent.innerText = ""; // Reset to blank.
        parent.appendChild(close);
    }

    let relayNum = (val) => val === RE_OFF ? "NONE" : Number(val);
    let reAltCond = (cond, val) => {
        const textConv = ["<", ">", "NONE"];
        if (cond == 2) return textConv[cond];
        return `${textConv[cond]} ${val.toFixed(1)}`;
    }

    // Pings the server to see if new firmware is available. If the server 
    // has a fw version different than the device, it will reply with the
    // new version, which will allow a clickable update.
    const checkNewFW = () => {
        return new Promise((resolve, reject) => {
        fetch(OTAURL)
        .then(res => res.json())
        .then(res => {
            const {version} = res;
            const noActionResp = ["Invalid JSON", "match", "wap", 
                "Connection open fail", "Connection init fail"];
                

            // If -1, means that there is an actual value, so the update
            // should be available in button form.
            if (noActionResp.indexOf(version) == -1) {
                const html = `<button id="FWbut" class="logFWbut" 
                    onclick="DLfirmware('${res.signatureURL}', 
                    '${res.firmwareURL}')"> Update to Version ${version}
                    </button>`;

                OTAdisp.innerHTML = html;
                resolve(200);
            }
        })
        .catch(err => reject(err));
    });
    }

    // Triggered by the DL firmware button. Downloads the OTA update,
    // and if successful, restarts the webpage. This will clear the button
    // since the versions will be matched.
    const DLfirmware = (sigURL, firURL) => {
        const URL = `${URLprotocol}://${URLbody}/OTAUpdate?url=${firURL}
            &sigurl=${sigURL}`;

        let updHTML = OTAdisp.innerHTML;

        fetch(URL)
        .then(res => res.json())
        .then(res => {
            const {status} = res;
            if (status === "OK") { // Exp response from the server.
                let secToReload = 10;
                let intervalID = setInterval(() => { // Countdown to reload
                    OTAdisp.innerText = `Restarting in ${secToReload--}`;
                    if (secToReload < 1) {
                        clearInterval(intervalID);
                        window.location.reload();
                    }
                }, 1000);
            } else {
                updHTML += " (Failed)";
                OTAdisp.innerHTML = updHTML;
            }
        })
        .catch(err => {
            updHTML += ` (Error)`;
            OTAdisp.innerHTML = updHTML;
        });
    }

    // When called, sets a timeout for 15 sec to check for OTA updates,
    // and start interval to update after n amount of time.
    let checkUpdates = () => {

        let runCheck = (curTime) => { // Runs 
            checkNewFW()
            .then(resp => {
                localStorage.setItem("OTA", curTime);
            })
            .catch(err => console.log(err));
        }

        setTimeout(() => runCheck(Date.now()), 15000); // Chk after 15 sec

        setInterval(() => {
            const lastCheck = Number(localStorage.getItem("OTA"));
            const curTime = Date.now();

            if (lastCheck === null) { // Has not been saved yet, first init.
                runCheck(curTime);
            } else {
                const expireTime = lastCheck + CHK_OTA_INTV;
                if (curTime >= expireTime) runCheck(curTime);
            }

        }, FW_CHECK_INTV);
    }

    // START CONTAINER OBJECTS. ================================================
    const mainCon = buildCon("main", null, null, null, null, null, null, null,
        {
            "units": new rangeBuild(0, 1, 1), "hour": new rangeBuild(0, 23, 1),
            "min": new rangeBuild(0, 59, 1)
        }
    );

    const tempCon = buildCon("temp", 
        new cmdBuild("ATTACH_RELAYS", handleTempHum),
        new cmdBuild("SET_TEMPHUM", handleTempHum),
        new cmdBuild("SET_TEMPHUM", handleTempHum), null, null, null, null, 
        {
            "re": new rangeBuild(0, 4, 1), "reCond": new rangeBuild(0, 2, 1),
            "reSet": new rangeBuild(-30, 60, 0.5), // Celcius
            "altCond": new rangeBuild(0, 2, 1),
            "altSet": new rangeBuild(-30, 60, 0.5) // Celcius
        }, true
    );

    const humCon = buildCon("hum", 
        new cmdBuild("ATTACH_RELAYS", handleTempHum),
        new cmdBuild("SET_TEMPHUM", handleTempHum),
        new cmdBuild("SET_TEMPHUM", handleTempHum), null, null, null, null,
        {
            "re": new rangeBuild(0, 4, 1), "reCond": new rangeBuild(0, 2, 1),
            "reSet": new rangeBuild(1, 99, 1), 
            "altCond": new rangeBuild(0, 2, 1),
            "altSet": new rangeBuild(1, 99, 1)
        }, true
    );

    const soilBuilder = (num) => {
        const soilCon = buildCon(`soil${num}`, null, null,
            new cmdBuild("SET_SOIL", handleSoil), null, null, null, null,
            {
                "altCond": new rangeBuild(0, 2, 1),
                "altSet": new rangeBuild(1, 4094, 1)
            }, true
        );

        return soilCon;
    }

    const soil1Con = soilBuilder(0);
    const soil2Con = soilBuilder(1);
    const soil3Con = soilBuilder(2);
    const soil4Con = soilBuilder(3);

    const lightCon = buildCon("light", 
        new cmdBuild("ATTACH_RELAYS", handlePhoto),
        new cmdBuild("SET_LIGHT", handlePhoto), null, 
        new cmdBuild("SET_LIGHT", handlePhoto), null, null, null,
        {
            "re": new rangeBuild(0, 4, 1), "reCond": new rangeBuild(0, 2, 1),
            "reSet": new rangeBuild(1, 4094, 1), 
            "darkSet": new rangeBuild(1, 4094, 1), 
        }, true
    );

    const specCon = buildCon("spec", null, null, null, null, 
        new cmdBuild("SET_SPEC_INTEGRATION_TIME", handleSpec),
        new cmdBuild("SET_SPEC_GAIN", handleSpec), null,
        {
            "astep": new rangeBuild(0, 65534, 1),
            "atime": new rangeBuild(0, 255, 1),
            "again": new rangeBuild(0, 10, 1)
        }, true
    );

    const relayBuilder = (num) => { // Do not change naming convention with re.
        const relayCon = buildCon(`re${num}`, null, null, null, null, null, 
            null, // Relay control is within the buildRelayButtons
            new cmdBuild("RELAY_TIMER", handleRelays),
            {
                "reHour": new rangeBuild(0, 23, 1),
                "reMin": new rangeBuild(0, 59, 1),
                "reCont": new rangeBuild(0, 3, 1), 
                "reTimer": new rangeBuild(0, 86399, 1),
                "reDur": new rangeBuild(1, 1439, 1)
            }, true
        );

        return relayCon;
    }

    const re1Con = relayBuilder(0);
    const re2Con = relayBuilder(1);
    const re3Con = relayBuilder(2);
    const re4Con = relayBuilder(3);

    const allCon = [mainCon, tempCon, humCon, soil1Con, soil2Con, soil3Con, 
        soil4Con, lightCon, specCon, re1Con, re2Con, re3Con, re4Con];

    // END CONTAINER OBJECTS. ================================================

    const buildContainers = () => allCon.forEach(con => buildRO(con));

    const addListeners = () => {
        allCon.forEach(con => {
            document.getElementById(con.buttonID).onclick = () => expand(con);
        });
    }

    let loadPage = () => { // Upon load, build everything.
        buildContainers();
        buildSpec();
        buildTrends();
        addListeners();
        initWebSocket(); // Inits the websocket protocol.
        getLog(); // Gets the log when loading the page.
        checkUpdates(); // Starts firmware checking timeout and interval.
    }

    </script>
    
</body>
</html>