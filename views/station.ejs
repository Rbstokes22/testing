<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greenhouse Controller</title>
    <style>
        
        button {
            border: 2px solid black;
            border-radius: 5px;
            min-height: 3em;
        }

        input {
            height: 2em;
        }

        body {
            color: black;
        }

        #title {
            text-align: center;
            font-size: 1.5em;
        }

        .sleekButton {
            text-align: center;
            background-color: black;
            color: white;
            border-radius: 5px;
            font-weight: 700;
        }

        #FWbut {background-color: red;} 

        /* 
        Creates as many col that will fit into container, if there is space
        will fill row with as many col as possible. Each col will have a min
        wid of 200px and a max of 1 fraction of available space, allowing
        col to grow to fill available space  
        */
        #container { 
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 10px;
        }

        .item {
            background-color: rgb(128, 251, 255);
            padding: 20px;
            text-align: left;
            border: 2px solid black;
        }

        .smallItem {
            padding: 5px;
            border: 2px solid black;
            text-align: left;
        }

        .con {
            display: grid;
            grid-template-columns: repeat(4, minmax(75px, 1fr));
            grid-template-rows: auto;
            gap: 10px;
            align-self: start; /* prevent stretching */
        }

        .conLab {
            color: rgb(255, 230, 0);
            font-weight: 900;
            background-color: rgb(0, 26, 255);
        }

        .valButton {
            border: 2px solid black;
            border-radius: 5px;
            height: 4em;
            width: 4em;
            text-align: center;
            padding: 20px;
        }

        #specDisp {
            display: grid;
            grid-template-columns: 60px auto;
            grid-template-rows: auto;
            gap: 5px;
            align-self: start;
            white-space: nowrap;
            background-color: rgb(0, 0, 0);
            color: rgb(255, 255, 255);
        }

        .span2 {grid-column: span 2;}
        .span3 {grid-column: span 3;}
        .span4 {grid-column: span 4;}
        .selected {background-color: rgb(255, 166, 0);}
        .boundBust, .badRange, .warning {
            background-color: rgb(196, 0, 0);
            color: white;
        }
        
        .dark {
            background-color: black;
            color: white;
        }
        .blinker {background-color: red;}

    </style>
</head>
<body onload="loadPage()">
    <p id="title">MysteryGraph Greenhouse</p>
    <div id="otaUpd"></div>
    <div id="timeCal"></div>

    <div id="container">
        <div id="mainCon" class="item"></div>
        <div id="tempCon" class="item"></div>
        <div id="humCon" class="item"></div>
        <div id="soil0Con" class="item"></div>
        <div id="soil1Con" class="item"></div>
        <div id="soil2Con" class="item"></div>
        <div id="soil3Con" class="item"></div>
        <div id="lightCon" class="item"></div>
        <div id="specCon" class="item"></div>
        <div id="re0Con" class="item"></div>
        <div id="re1Con" class="item"></div>
        <div id="re2Con" class="item"></div>
        <div id="re3Con" class="item"></div>
    </div> <!-- contains all periph containers-->
    
    <div id="log"></div>

    <button id="logBut" class="sleekButton" onclick="openLog()">Open Log</button>

    <script>

    // Currently on main display. Work setting the inputs upon expand. Once 
    // complete, build the trend box. Once that is done, add a button to 
    // save and restart. Once all tests well, clean up all code, comments,
    // and move to the ESP for testing.

    // MAIN display
    // [RO] Systime | Version  (use sysTime not hhmmss)
    // [RO] Units | timeCalib bool
    // [RO] Average Clear Time
    // [RO] Trend box, like spec disp. Make div. Include Buttons for 3, 6, 9, 12
    //      Text display only. Displays all trend data, not only a single one.
    // [INP] Units BUTTON
    // [INP] Clr Time hh
    // [INP] Clr Time mm BUTTON
    //  

    // Network and Sockets
    const re = /(https?):\/\/([a-zA-Z0-9.-]+(:\d+)?)/; // Regex
    const URLdata = re.exec(window.location.href);
    const URLprotocol = URLdata[1]; // http or https
    const URLbody = URLdata[2]; // main url
    const OTAURL = `${URLprotocol}://${URLbody}/OTACheck`; 
    const logURL = `${URLprotocol}://${URLbody}/getLog`;
    const webSktURL = `ws://${URLbody}/ws`;
    // const webSktURL = "ws://greenhouse.local/ws"; // Testing only

    // Elements
    const OTAdisp = document.getElementById("otaUpd");

    // Key names are colors that correspond with the JSON socket data. arr[0]
    // is the wavelength, arr[1] is the display bar color, and arr[2] is the 
    // is if the color is 0 (light) or 1 (dark), to adjust background text.
    const COLORS = {
        "violet": ["415nm", "violet", 1], "indigo": ["445nm", "indigo", 1],
        "blue": ["485nm", "blue", 1], "cyan": ["515nm", "cyan", 0],
        "green": ["555nm", "green", 1], "yellow": ["590nm", "yellow", 0],
        "orange": ["630nm", "orange", 0], "red": ["680nm", "red", 1],
        "nir": ["NIR", "rgb(140, 0, 0)", 1], "clear": ["Clear", "white", 0]
    };
    
    const MAX_SPEC_PX = 250; // Max color count pixels.

    // Intervals (millis)
    const POLL_INTV = 1000; // Poll interval to run GET_ALL.
    const CHK_OTA_INTV = 86400000; // OTA check run.
    const CLEAR_REQ_INTV = 60000; // Clear exp skt req if non-response.
    const FW_CHECK_INTV = 12 * 60 * 60 * 1000; // Check for new firmware.

    // Flags 
    let Flags = {SKTconn:false, openLog:true};

    // Other
    const maxID = 255; // Used to reset ID num to 0 when this value is reached.
    const logDelim = ';';
    const RE_OFF = 255; // Signals relay is not attached.
    let isCelcius = false;
    const sensUpBg = ["yellow", "rgb(0, 224, 27)"]; // Sensor up background clr
    let specDisplay = 'C'; // 'C'urrent, 'A'verages, 'P'rev Averages.

    // All commands from socketHandler.hpp. These must correspond with the
    // enum. Will be used to return the index num, which will be the cmd.
    let CMDS = [null, // Used to index to a +1
        "GET_ALL", "CALIBRATE_TIME", "NEW_LOG_RCVD", "RELAY_CTRL", 
        "RELAY_TIMER", "ATTACH_RELAYS", "SET_TEMPHUM", "SET_SOIL", "SET_LIGHT", 
        "SET_SPEC_INTEGRATION_TIME", "SET_SPEC_GAIN", "CLEAR_AVERAGES", 
        "CLEAR_AVG_SET_TIME", "SAVE_AND_RESTART", "GET_TRENDS"];

    // Declare all vars here, to save space. idNum is used to keep track of
    // socket commands, allData contains all sensor data, and log contains
    // all log entries.
    let socket, poll, clearReqID, requestIDs = {}, idNum = 0,
        allData = {}, log = [], trends = {}, Expansions = {};

    // element build. Requires the parent ID, and both the read only and 
    // input objects. Returns constructed object.
    let eleBuild = function(parentID, readOnly, inputs) {
        this.parentID = parentID; // Used to link it to parent container.
        this.readOnly = readOnly; // Sensor and setting data.
        this.inputs = inputs; // Interactive.
        this.buttonID = `${parentID}Exp`; // Expansion button.
        return this;
    }

    // Read only build. Requires the element type, its text, and and array
    // of all classes pertaining to it. Returns constructed object.
    let RObuild = function(eleType, text, classes) {
        this.eleType = eleType; // element type. i.e. "div".
        this.text = text; // Default input text.
        this.classes = classes; // array of classes.
        return this;
    }

    // Input build. Builds the interactive portion to make adjustments to
    // system settings. Pass null if non-exist. Returns constructed object.
    let inputBuild = function(ranges, eleType, label, incBut, 
        classes, dataPtr, rangeMap, specMap, butFunc) {

        this.ranges = ranges; // All the applicable input ranges
        this.eleType = eleType; // element type. i.e. "input".
        this.label = label; // input box label.
        this.incBut = incBut; // bool. Include button.
        this.classes = classes; // array of classes.
        this.dataPtr = dataPtr; // pointer/key of allData JSON.

        // Maps. The range map is an array that has display values with an
        // index that corresponds with an actual numberical value. Special
        // maps are used for values outside of the typical range and are 
        // passed as objects.
        this.rangeMap = rangeMap; 
        this.specMap = specMap;
        this.butFunc = butFunc; // function applied to button onclick.
        return this;
    }

    // Command build. Pass the command string, and the callback function. 
    // Returns constructed object that will be called when submit is sel.
    let cmdBuild = function(cmd, callBack) {
        this.cmd = cmd;
        this.callBack = callBack;
        return this;
    }

    let rangeBuild = function(min, max, step) {
        this.min = min; // range minimum
        this.max = max; // range max
        this.step = step; // Step size
        return this;
    }

    let makeNum = (ID) => { // Used to ref ID, and return Number of the value.
        return Number(document.getElementById(ID).value);
    }

    // Checks the value and that it is within the specified range. Changes BG
    // to green and returns true upon success, and upon failure, alerts, and
    // changes the BG to red returning false.
    let QC = (val, ranges, parentID, isTemp = false) => {
        const ele = document.getElementById(parentID);

        val = isTemp ? val / 100 : val; // If temperature, div val by 100.

        if (val >= ranges.min && val <= ranges.max) {
            ele.classList.remove("badRange")
            ele.style.backgroundColor = "rgb(0, 224, 27)";
            return true;

        } else {

            ele.classList.add("badRange");
            if (!isCelcius) {
                window.alert(`${((val * 1.8) + 32).toFixed(1)} out of range ` +
                    `${((ranges.min * 1.8) + 32).toFixed(1)} to ` +
                    `${((ranges.max * 1.8) + 32).toFixed(1)}`);
            } else {
                window.alert(`${val} out of range ${ranges.min} to ` +
                `${ranges.max}`);
            }
            return false;
        }
    }

    let timeStr = (seconds, returnRaw = false) => {
        const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
        const s = (seconds % 60).toString().padStart(2, '0');
        return (returnRaw) ? [h, m, s]: `${h}:${m}:${s}`;
    }

    let buildSpec = () => { // spectral display in specCon.
        const disp = document.getElementById("spec"); // Primary display bar
        const parent = document.getElementById("specDisp");

        const fontColor = ["black", "white"]; // Used for color bars.

        let updDisp = (color, ele) => {
            disp.innerText = 
                `${color.toUpperCase()} | ${ele.value}/65535 counts | ` +
                `${(ele.value/655.35).toFixed(2)}%`;
        }

        Object.keys(COLORS).forEach(color => {
            const e = document.createElement("div");
            const lab = document.createElement("div"); // Label
            e.style.backgroundColor = `${COLORS[color][1]}`;
            e.style.color = fontColor[COLORS[color][2]];
            lab.innerText = COLORS[color][0];
            e.id = color;
            // Add count and color data to display for click or mouseover .
            e.onclick = () => updDisp(color, e);
            e.onmouseover = () => updDisp(color, e);
            lab.onclick = () => updDisp(color, e); // E holds the data.
            lab.onmouseover = () => updDisp(color, e);
            parent.appendChild(lab);
            parent.appendChild(e);
        });

        const buttons = {"Current": 'C', "Avgs": 'A', "Prev Avgs": 'P'};
        Object.keys(buttons).forEach(name => {
            const b = document.createElement("button");
            b.innerText = name;
            b.classList.add("span2");
            b.id = `${buttons[name]}Spec`;
            b.addEventListener("click", () => {
                specDisplay = buttons[name]; // Change global
                handleSpec(); // Update changes.
            });
            parent.appendChild(b);
        });
    }

    let buildConLabel = (parent, name) => {
        const label = document.createElement("input");
        label.className = "smallItem span2 conLab";
        const curVal = localStorage.getItem(`${name}Label`);
        label.value = (curVal != null) ? curVal : "CUSTOM LABEL HERE";
        label.onblur = () => localStorage.setItem(`${name}Label`, label.value);
        parent.appendChild(label);
    }

    let buildRelayButtons = (container, reNum) => {
        const Labs = ["OFF", "ON", "FORCE OFF", "FORCE RMV"];
        const parent = document.getElementById(`${container.parentID}Buttons`);
        const key = container.parentID.slice(0, 3);

        Labs.forEach((but, idx) => { // Build each button functionality.
            const b = document.createElement("button");
            b.innerText = but;
            b.id = `${container.parentID}But${idx}`; // Ex relay0ConBut0 = OFF
            b.value = idx;
            b.enabled = true;
        
            b.onclick = () => {
                if (!b.enabled) return; // Block if button is disabled.
                const cmd = convert("RELAY_CTRL");
                const ID = getID(defResp, {[`${key}`]: Number(b.value)}, 
                    handleRelays);

                let output = ((reNum & 0xF) << 4); // Set renum to init
                output |= (b.value & 0xF); // Set the control value.
                

                socket.send(`${cmd}/${output}/${ID}`);
            }

            parent.appendChild(b);
        });
    }

    // The primary build container, each subcontainer of container, will be
    // built here. Constructs container by building read only (RO) and input 
    // (INP) elements. Returns the build container. Params are commands that
    // include buttons. All containers are built using these cookie cutter
    // params, special commands that are associate by name, or both.
    let buildCon = (name, re, reSet, altSet, darkSet, integ, gain, 
        reTimer, ranges, includeLabel = false) => {
        
        // ATTENTION: Read only will consist of data reported by ESP. It
        // will show for example, temperature, relay, and alert settings.
        // Input will allow those settings to be changed by signalling the srvr.

        let RO = {}, INP = {}; // Read only and Input.

        // Add the container class to give the grid attributes and allow input
        // label.
        const parent = document.getElementById(`${name}Con`);
        parent.classList.add("con");
        if (includeLabel) buildConLabel(parent, name);

        // Special conditions for the main display/RO setup
        if (name === "spec") { // Spectral display

            RO[`${name}Disp`] = new RObuild("div", null, 
                ["smallItem", "span4"]); // Display for spec chart.

            RO[name] = new RObuild("div", "Spectral Info Display", 
                ["smallItem", "span4"]); // Primary display for info

        } else if (name.includes("re")) { // Relay displays

            RO[name] = new RObuild("div", `Plug #${Number(name[2]) + 1}`,
                ["smallItem", "span4"]); // Displays the relay number

            RO[`${name}ConButtons`] = new RObuild("div", "", 
                ["smallItem", "span4", "con"]); // button display.

        } else if (name === "main") {

            RO[name] = new RObuild("div", "0", ["smallItem", "span4"]);
            RO[`${name}Alt`] = new RObuild("div", "0", ["smallItem", "span4"]);
            RO[`${name}Avg`] = new RObuild("div", "0", ["smallItem", "span4"]);
            RO[`${name}Trends`] = new RObuild("div", null, 
                ["smallItem", "span4"]); // Houses trends built by buildTrend

            INP[`${name}Units`] = new inputBuild(ranges.units, "input", "Units",
                true, ["smallItem"], null, ['F', 'C'], null, () => {
                // Allows updates to units.
                const val = makeNum(`${name}UnitsHidden`);
                isCelcius = val ? true : false;
                handleMain(); handleTempHum();
            });

            INP[`${name}HrSet`] = new inputBuild(ranges.hour, "input",
                "Avg Clear Hours:", false, ["smallItem"], null, null, null, 
                null);

            INP[`${name}MinSet`] = new inputBuild(ranges.min, "input",
                "Avg Clear Minutes:", true, ["smallItem"], null, null, null, 
                () => {
                
                const cmd = convert("CLEAR_AVG_SET_TIME");
                const hr = makeNum(`${name}HrSet`);
                const min = makeNum(`${name}MinSet`);

                if (QC(hr, ranges.hour, `${name}HrSet`) && 
                    QC(min, ranges.min, `${name}MinSet`)) {

                    let sendTime = (hr * 3600) + (min * 60);
                    sendTime = sendTime > 86340 ? 86340 : sendTime;

                    const ID = getID(defResp, {"temp" : 120}, 
                        handleMain);

                    socket.send(`${cmd}/${sendTime}/${ID}`);
                }
            });


        } else { // All other displays.
            RO[name] = new RObuild("div", "0", ["smallItem", "span4"]); 
        }

        // Building of the individual RO and Inputs. (COOKIE CUTTER)

        if (re) { // Relay selection. If exists, builds boxes.
            RO[`${name}Re`] = new RObuild("div", "0", ["smallItem", "span4"]);

            INP[`${name}ReAtt`] = new inputBuild(ranges.re, "input", "Plug #", 
                true, ["smallItem"], `${name}Re`, ['1', '2', '3', '4', "NONE"], 
                {255: ["NONE", 4]}, () => {
                    
                const cmd = convert(re.cmd); 
                const reNum = makeNum(`${name}ReAttHidden`);

                // Updates the diplay using ESP32 protocol.
                const disp = (reNum == 4 ) ? RE_OFF : reNum;
                
                if (QC(reNum, ranges.re, `${name}ReAtt`)) {

                    const ID = getID(defResp, {[`${name}Re`]: disp}, 
                        re.callBack);

                // IAW ESP32 bitwise protocol, adjust value to send.
                    let output = reNum & 0xF; // Set in the lower 4 bits.

                    switch (name) {
                        // No action required or temp.
                        case "hum": output |= (1 << 4); break;
                        case "light": output |= (2 << 4); break;
                    }

                    socket.send(`${cmd}/${output}/${ID}`);
                }
            });
        }

        if (reSet) { // Relay setting condition and value.
            INP[`${name}ReLTGT`] = new inputBuild(ranges.reCond, "input", 
                "Plug condition", false, ["smallItem"], `${name}ReCond`, 
                ["Less Than", "Gtr Than", "NONE"], null, null);

            INP[`${name}ReSetAdj`] = new inputBuild(ranges.reSet, "input", 
                `Plug ${name} value`, true, ["smallItem"], `${name}ReVal`, null, 
                null, () => {
                
                const cond = makeNum(`${name}ReLTGTHidden`); // relay condition.
                const cmd = convert(reSet.cmd); // Returns number.
                let val = makeNum(`${name}ReSetAdj`);

                // If temperature, ensures value is in celcius, and mult
                // float val by 100 IAW ESP req.
                if (name === "temp") { 
                    val = isCelcius ? val * 100 : 
                        (((val - 32) / 1.8).toFixed(2) * 100);
                }

                if (QC(cond, ranges.reCond, `${name}ReLTGT`) &&
                    QC(val, ranges.reSet, `${name}ReSetAdj`, name === "temp")) {

                    const ID = getID(defResp, 
                        {[`${name}ReCond`]: cond, [`${name}ReVal`]: val}, 
                        reSet.callBack);

                    // IAW ESP32 bitwise protocol, adjust value to send. 
                    let output = 0; // init to 0.

                    switch (name) { // Soil has no relay.
                        case "temp": 
                        output |= (1 << 25); // 1 for temperature
                        output |= ((cond & 0b11) << 16); // 2 bit max.
                        output |= (val & 0xFFFF); // Ensure only lower 16-bits
                        break;

                        case "hum": // No sensor action req, passes 0.
                        output |= ((cond & 0b11) << 16); // 2 bit max.
                        output |= (val & 0xFFFF); // only lower 16-bits.
                        break;

                        case "light": 
                        output |= (1 << 28); // 1 for photoresistor
                        output |= ((cond & 0b11) << 24);
                        output |= (val & 0x0FFF);
                        break;
                    }

                    socket.send(`${cmd}/${output}/${ID}`);  
                }
            });
        }

        if (altSet) { // Alert setting condition and value.
            RO[`${name}Alt`] = new RObuild("div", "0", ["smallItem", "span4"]);

            INP[`${name}AltLTGT`] = new inputBuild(ranges.altCond, "input", 
                "Alert condition", false, ["smallItem"], `${name}AltCond`, 
                ["Less Than", "Gtr Than", "NONE"], null, null);

            INP[`${name}AltSetAdj`] = new inputBuild(ranges.altSet, "input", 
                `Alert ${name} value`, true, ["smallItem"], `${name}AltVal`, 
                null, null, () => {

                const cond = makeNum(`${name}AltLTGTHidden`); // alert cond.
                let val = makeNum(`${name}AltSetAdj`);
                const cmd = convert(altSet.cmd); // returns number.

                // If temperature, ensures value is in celcius, and mult
                // float val by 100 IAW ESP req.
                if (name === "temp") { // Adjust based on requirements
                        val = isCelcius ? val * 100 : 
                            (((val - 32) / 1.8).toFixed(2) * 100);
                }

                if (QC(cond, ranges.altCond, `${name}AltLTGT`) &&
                    QC(val, ranges.altSet, `${name}AltSetAdj`, 
                        name === "temp")) {

                    const ID = getID(defResp, 
                        {[`${name}AltCond`]: cond, [`${name}AltVal`]: val}, 
                        altSet.callBack);

                    // IAW ESP32 bitwise protocol, adjust value to send.
                    let output = 0;

                    if (name === "temp") {
                        output |= (1 << 25); // 1 for temperature.
                        output |= (1 << 24); // 1 for alert.
                        output |= ((cond & 0b11) << 16); // Condition
                        output |= (val & 0xFFFF); // Lower 16 bits is value.

                    } else if (name === "hum") {
                        output |= (1 << 24); // 1 for alert.
                        output |= ((cond & 0b11) << 16); // Condition
                        output |= (val & 0xFFFF); // Lower 16 is value.

                    } else if (name.includes("soil")) {
                        const sensNum = Number(name[4]); // Last char, soil(1)
                        output |= ((sensNum & 0xF) << 20); // Sensor number
                        output |= ((cond & 0b11) << 16); // Condition
                        output |= (val & 0xFFFF); // Lower 16 is value.
                    }

                    socket.send(`${cmd}/${output}/${ID}`);  
                }
            });
        }

        if (darkSet) { // Keeps track of the duration of light that exceeds val.
            RO[`${name}Dur`] = new RObuild("div", "0", ["smallItem", "span4"]);

            RO[`${name}Dark`] = new RObuild("div", "0", ["smallItem", "span4"]);

            INP[`${name}DarkSet`] = new inputBuild(ranges.darkSet, "input",
                "Dark value", true, ["smallItem"], "darkVal", null, null,
                () => {
                    const cmd = convert(darkSet.cmd); // returns number.
                    const val = makeNum(`${name}DarkSet`);

                    if (QC(val, ranges.darkSet, `${name}DarkSet`)) {
                        const ID = getID(defResp, {"darkVal": val}, 
                            darkSet.callBack);

                        let output = val & 0x00FFF000; // Nothing else req.
                        socket.send(`${cmd}/${output}/${ID}`);
                    }
                }
            )
        }

        if (integ) { // Spectal integration ATIME + 1 * ASTEP + 1 * 0.00278.

            INP[`${name}Astep`] = new inputBuild(ranges.astep, "input",
                "Integration (step)", false, ["smallItem"], "astep", null,
                null, null
            );

            INP[`${name}Atime`] = new inputBuild(ranges.atime, "input",
                "Integration (time)", true, ["smallItem"], "atime", null,
                null, () => {

                const ASTEP = makeNum(`${name}Astep`);
                const ATIME = makeNum(`${name}Atime`);
                const cmd = convert(integ.cmd); // Returns number.

                if (QC(ASTEP, ranges.astep, `${name}Astep`) && 
                    QC(ATIME, ranges.atime, `${name}Atime`)) {

                    const ID = getID(defResp, {"astep": ASTEP, "atime": ATIME}, 
                        integ.callBack);

                    let output = ATIME & 0xFF; // Establish Atime on init.
                    output |= ((ASTEP & 0xFFFF) << 8);
                    socket.send(`${cmd}/${output}/${ID}`);
                }
                }
            );
        }

        if (gain) { // Spectral gain.

            INP[`${name}Again`] = new inputBuild(ranges.again, "input",
                "Spectral Gain", true, ["smallItem"], "again", 
                ["0.5x", "1x", "2x", "4x", "8x", "16x", "32x", "64x", "128x",
                    "256x", "512x"], null, () => {

                const AGAIN = makeNum(`${name}Again`);
                const cmd = convert(gain.cmd);

                if (QC(AGAIN, ranges.again, `${name}Again`)) {

                    const ID = getID(defResp, {"again": AGAIN}, gain.callBack);
                    socket.send(`${cmd}/${AGAIN}/${ID}`);
                }
                }
            );
        }

        if (reTimer) { // Relay timer.
            RO[`${name}Stat`] = new RObuild("div", "0", ["smallItem", "span4"]);

            INP[`${name}HrSet`] = new inputBuild(ranges.reHour, "input",
                "On Time (HH MM):", false, ["smallItem"], null, null, null, 
                null);

            INP[`${name}MinSet`] = new inputBuild(ranges.reMin, "input",
                null, false, ["smallItem"], null, null, null, 
                null);

            INP[`${name}HrOff`] = new inputBuild(ranges.reHour, "input",
                "Off Time (HH MM):", false, ["smallItem"], null, null, null, 
                null);

            INP[`${name}MinOff`] = new inputBuild(ranges.reMin, "input",
                null, true, ["smallItem"], null, null, null, 
                (toDisable = false) => {

                const cmd = convert(reTimer.cmd);

                // If disable is set to true, zeros out values to force the 
                // timer to disable.
                const onHr = makeNum(`${name}HrSet`);
                const onMin = makeNum(`${name}MinSet`);
                const offHr = makeNum(`${name}HrOff`);
                const offMin = makeNum(`${name}MinOff`);

                if (QC(onHr, ranges.reHour, `${name}HrSet`) &&
                    QC(onMin, ranges.reMin, `${name}MinSet`) &&
                    QC(offHr, ranges.reHour, `${name}HrOff`) &&
                    QC(offMin, ranges.reMin, `${name}MinOff`)) {

                    let output = 0;
                    if (name.includes("re")) { // Ensures it is a relay.
                        
                        const reNum = Number(name[2]); // Last char, relay(1).
                        const onTime = (onHr * 3600) + (onMin * 60);
                        const offTime = (offHr * 3600) + (offMin * 60);
                        let duration = (onTime < offTime) ? (offTime - onTime) :
                            (86400 - onTime + offTime);

                        duration = Math.floor(duration / 60); // s to min int.
                        let ID = -1; // Will be used depending on values.

                        if (onTime === offTime) { // Signal to remove timer.
                            output |= ((99999 & 0x1FFFF) << 11); // bits 11-28
                            ID = getID(defResp, 
                                {[`re${reNum}TimerEn`]: 0, 
                                 [`re${reNum}TimerOn`]: 99999,
                                 [`re${reNum}TimerOff`]: 99999},
                                reTimer.callBack);

                        }  else {
                            output |= ((onTime & 0x1FFFF) << 11); // bits 11-28
                            ID = getID(defResp, 
                                {[`re${reNum}TimerEn`]: 1, 
                                 [`re${reNum}TimerOn`]: onTime,
                                 [`re${reNum}TimerOff`]: offTime},
                                reTimer.callBack);
                        }

                        output |= ((reNum & 0xF) << 28); // MSNibble
                        output |= (duration & 0x7FF); // bits 0 - 10
                        socket.send(`${cmd}/${output}/${ID}`); 
                    }
                }
                }
            );
        }

        // Once all selection have been built, build expan button and
        // adjustment bar.
        RO[`${name}ConExp`] = new RObuild("button", "Expand", ["span4"]);

        return new eleBuild(`${name}Con`, RO, INP); // Return object.
    }

    // After the container has been constructed using buildCon, it is passed 
    // here which will build the read only portion of the container.
    let buildRO = (container) => {

        // Iterates each read only key, creates and builds elements.
        Object.keys(container.readOnly).forEach(eleID => {
            const data = container.readOnly[eleID];
            const e = document.createElement(data.eleType);
            e.id = eleID;
            e.innerText = data.text
            data.classes.forEach(cls => { // add classes to list.
                if (cls == null || cls == undefined) return;
                e.classList.add(cls);
            });
            document.getElementById(container.parentID).appendChild(e);
        });

        // Build the relay control buttons after RO is built.
        if (container.parentID.includes("re")) {
            buildRelayButtons(container, container.parentID[2]); // 3rd char.
        }
    }

    // After the container read only portion has been built, the expand button
    // will call this function, passing the container. This will build the 
    // remaining portion of the container which is the interactive input part.
    let expand = (container) => {
        const button = document.getElementById(container.buttonID);
        const inp = container.inputs;
        const ID = container.parentID;
        let idx = 0; // USed for expansion elements.

        let append = (ele) => {
            document.getElementById(ID).appendChild(ele);
            Expansions[ID].push(ele.id);
        }

        if (button.innerText === "Expand") {
            Expansions[ID] = []; // Clear before use.

            Object.keys(inp).forEach(ele => {
                const data = inp[ele];
                const label = buildLabel(ele, data); // Null if no label.
                const e = buildInput(ele, data, container.parentID);
                const but = data.incBut ? buildButton(ele, data) : null;

                // Build hidden carrier input if range map attached. This 
                // allows separation of real values and display values.
                const hidden = data.rangeMap ? buildHidden(ele, data) : null;
    
                // Append all newly created elements to the parent container.
                if (label) append(label);
                append(e);
                if (hidden != null) append(hidden);
                if (but != null) append(but); // append last.
        
                data.classes.forEach(cls => { // Add classes
                    if (cls == null || cls == undefined) return; // none
                    e.classList.add(cls);
                });

                // input listeners will link the adjustment bar with the 
                // input box for dynamic value display.
                if (data.eleType === "input") addListener(e, hidden, ID, data);
            });

            // For input adjustment tools.
            let adj = document.createElement("div");
            adj.innerText = "Adjustments";
            adj.id = `${ID}Adj`;
            adj.className = "span4 smallItem con";
            append(adj);

            button.innerText = "Contract"; // acts as a toggle and display.

        } else if (button.innerText === "Contract") { // Remove expanded eles.
            Expansions[ID].forEach(id => document.getElementById(id).remove());
            button.innerText = "Expand";

            if (container.parentID === "specCon") { // Special rules
                const integ = document.getElementById("spec");
                integ.innerText = "Spectral Info Display";
                integ.classList.remove("selected");
            }
        }
    }

    // When building the interactive part of the container, builds the labels
    // for each input using the parent ID, and the input object data.
    let buildLabel = (inpID, data) => {
        if (!data.label) return null; // Prevents label if not set.
        const label = document.createElement("div");
        label.style.gridColumn = "1 / 3"; // Span 2 if regular inp
        label.innerText = data.label; 
        label.style.alignContent = "center"; // Keep inline with input boxes.
        label.id = `${inpID}Lab`;
        return label;
    }

    // Input will always be displayed. If a range map is sent, this will turn 
    // the input into display only, and a hidden input will be build and 
    // populated with a numerical value. If no map is sent, serves as both an
    // input and display.
    let buildInput = (inpID, data, contID) => {

        const ele = document.createElement(data.eleType);
        ele.id = inpID; 

        // No pointer/key to JSON key/val. main passes variable, which can be
        // true or false, so it is ignored here.
        if (!data.dataPtr && !inpID.includes("main")) { 
            ele.value = 0;

            if (inpID.includes("re")) { // Check if it is a relay.
                const reTag = inpID.slice(0, 3); // Will extract reN.
            
                if (allData[`${reTag}TimerEn`]) { // check for enabled
                    const rest = inpID.slice(3, inpID.length); // Remaining

                    // Gets times in seconds
                    const onTime = allData[`${reTag}TimerOn`];
                    const offTime = allData[`${reTag}TimerOff`];

                    switch (rest) { // Sets the value to the appropriate value.
                        case "HrSet":
                        ele.value = timeStr(onTime, true)[0]; break;

                        case "MinSet":
                        ele.value = timeStr(onTime, true)[1]; break;

                        case "HrOff": 
                        ele.value = timeStr(offTime, true)[0]; break;

                        case "MinOff":
                        ele.value = timeStr(offTime, true)[1]; break;
                    }

                    return ele; // return to break, default will set val = 0.
                } 
            }
            ele.value = 0; // 0 value.
            return ele;
        }

        // Get the true data depending on the type of data pointer being a var,
        // or a JSON K/V pair. Main includes global var for temp units.
        const val = (inpID.includes("main")) ? Number(isCelcius) : 
            allData[data.dataPtr];

        if (data.rangeMap) { // Checks for rangeMap. If true...
            ele.readOnly = true; // Forces use of adjustment bar.

            // Checks for a special map and that the range map value does not
            // eixst. If true, sets to special map, if false, uses range map/
            if (data.specMap && !data.rangeMap[val]) {
                ele.value = data.specMap[val][0];
            } else {
                ele.value = data.rangeMap[val];
            }

        } else {

            ele.readOnly = false; // Allows use of input or adj bar.

            // ESP rules dictate that temp is passed in C multiplied by 100 for
            // float point precision. 
            if (contID === "tempCon") {ele.value = isCelcius ? 
                Number(val / 100).toFixed(1) :
                Number(((val / 100) * 1.8) + 32).toFixed(1);
            } else {
                ele.value = val;
            }
        }

        return ele;
    }

    // builds submit button for input items.
    let buildButton = (inpID, data) => {
        const button = document.createElement("button");
        const isRelay = inpID.includes("re");
        button.id = `${inpID}But`;
        const reText = "Submit (hold to disable timer)";

        // Timeout stuff is used only for the relay button, to disable timer.
        let holdTimeout = 0; 
        let startHold = () => { // timeout to set vals to 0 before submit.
            holdTimeout = setTimeout(() => {
                const tag = inpID.slice(0, 3);
                document.getElementById(`${tag}HrSet`).value = 0;
                document.getElementById(`${tag}MinSet`).value = 0;
                document.getElementById(`${tag}HrOff`).value = 0;
                document.getElementById(`${tag}MinOff`).value = 0;
                button.innerText = "RELEASE"
                button.classList.add("warning");
            }, 500);
        }
        
        let endHold = () => {
            clearTimeout(holdTimeout);
            button.innerText = reText;
            button.classList.remove("warning");
        }

        button.innerText = isRelay ? reText : "Submit";
        button.onclick = () => data.butFunc();

        // If not relay, returns with on click. If relay, add additional listen.
        if (!inpID.includes("re")) return button; 
        button.classList.add("span4");
        button.addEventListener("mousedown", startHold);
        button.addEventListener("mouseup", endHold);
        button.addEventListener("touchstart", startHold);
        button.addEventListener("touchend", endHold);
        return button;
    }

    let buildHidden = (inpID, data) => { // This will contain real values
        const actual = document.createElement(data.eleType);
        actual.type = "hidden";
        actual.id = `${inpID}Hidden`;

        // Special conditions for setting the hidden input value.
        actual.value = (inpID === "mainUnits") ? Number(isCelcius) : 
            allData[data.dataPtr]; // Handles main, since global var is passed.
  
        if (data.specMap) { // Adjusts real values if specMap and data conflict.
            Object.keys(data.specMap).forEach(key => {
                if (key == allData[data.dataPtr]) {
                    // adjust val if current json val == a spec map key val.
                    actual.value = data.specMap[allData[data.dataPtr]][1];
                }
            });
        }

        return actual;
    }

    let addListener = (disp, hidden, ID, data) => {

        // The adjusted value is passed and the display value will be adjusted
        // as well as the hidden (true) value if a range map is passed.
        let adjVals = (adjVal) => { 

            if (hidden) (hidden.value = adjVal);

            // Adjust the display value using the range map or the adj value.
            disp.value = (data.rangeMap === null) ? 
                adjVal : data.rangeMap[adjVal];

            if (ID === "specCon") { // Allow display of integration time.
                const ASTEP = makeNum("specAstep");
                const ATIME = makeNum("specAtime");
                const AGAIN = makeNum("specAgain");
                const DISP = document.getElementById("spec"); // main element
                const intTime = (ASTEP + 1) * (ATIME + 1) * 0.00278;

                DISP.innerText = `Integration Time: ${intTime.toFixed(1)} ms`;
                DISP.classList.add("selected");
            }
        }
        
        // When an input is focused, It takes ownership of the adjustment bar.
        disp.addEventListener("focus", () => {
            
            let min = data.ranges.min;
            let max = data.ranges.max;
            let step = data.ranges.step;

            if (["tempReVal", "tempAltVal"].indexOf(data.dataPtr) != -1 &&
                !isCelcius) { // Convert to F if set, before use.
                min = (min * 1.8) + 32;
                max = (max * 1.8) + 32;
                step = 1; // smaller step size is only dedicated to celcius.
            }

            const adj = document.getElementById(`${ID}Adj`);
            adj.innerHTML = `<input id="${ID}AdjBar" type="range" ` + 
                `class="span4" width="300px min="${min}" max="${max}" ` +
                `step="${step}">`;
            
            const AdjBar = document.getElementById(`${ID}AdjBar`);
            AdjBar.addEventListener("input", () => adjVals(AdjBar.value));

            // Specify params for buttons.
            ['-', '+'].forEach(label => { // Increases adjustment granularity.
                const but = document.createElement("button");
                but.classList.add("span2");
                but.id = `${ID}${label}`; // Should be like tempCon+
                but.innerText = `${label} ${step}`;
                adj.appendChild(but);

                // Event listener directly controls the adjbar, which then 
                // Adjusts the box value.
                but.addEventListener("click", () => {

                    if (label === '+') {
                        AdjBar.value = Number(AdjBar.value) + Number(step);
                    } else {
                        AdjBar.value = Number(AdjBar.value) - Number(step);
                    }
                    
                    adjVals(AdjBar.value);
                });
            });


            if (data.rangeMap != null) { // Set upon expansion.
                AdjBar.value = data.rangeMap.indexOf(disp.value);
            } else {
                AdjBar.value = disp.value; 
            }

            disp.classList.add("selected");
        });

        disp.addEventListener("blur", () => {
            disp.classList.remove("selected");
        });
    }

    // Returns the index of the command, this is used with esp32 ssocket
    // command as argument 1.
    const convert = (CMD) => Number(CMDS.indexOf(CMD));

    // Requires callback function for a successful update, the key/value
    // pairs with the key being the allData JSON key, and its value to
    // update to, and the second callback function which will run after
    // the JSON has been updated, to update the display. Returns the ID.
    const getID = (callback1 = null, KVs = null, callback2 = null) => {
        const id = idNum++;
        requestIDs[id] = [callback1, KVs, callback2]; 
        idNum = (idNum >= maxID) ? 0 : idNum; // Reset to 0 if == max.
        return id;
    }

    // No params. Returns true if socket is open, false if not.
    const isSocketOpen = () => (Flags.SKTconn && WebSocket.OPEN);

    // SOCKETS. Event handlers.
    const initWebSocket = () => {
        console.log("Init websocket");
        socket = new WebSocket(webSktURL); // Open new socket.
        socket.onopen = socketOpen; // Set the event handler functions.
        socket.onclose = socketClose;
        socket.onmessage = socketMsg;
    }

    const socketOpen = () => { // Open socket handler
        console.log("Connected to server");
        Flags.SKTconn = true;
        poll = setInterval(pollServer, POLL_INTV); // Set intervals
        clearReqID = setInterval(clearOldRequests, 10000);
    }

    const socketClose = () => { // Close socket handler
        console.log("Disconnected from server");
        Flags.SKTconn = false;
        clearInterval(poll); // Clear intervals.
        clearInterval(clearReqID);
        setTimeout(initWebSocket, 2000); // Attempt reconnect.
    }

    // Messages from server will be in JSON format, parsed, and sent to the
    // assigned function to handle that response.
    const socketMsg = (event) => handleResponse(JSON.parse(event.data)); 

    // Receives the parsed JSON response from the socket message. Gets its
    // function from the ID, runs the function passing the response, and
    // deletes the ID signifying the request is complete.
    const handleResponse = (response) => {
        const func = requestIDs[response.id][0]; // callback function
    
        // Check if default response. If so, will send the html element
        // ID and the value to set it to iff successful. This will handle
        // most socket responses.
        if (func === defResp && response.status === 1) { // 1 = success
            func(requestIDs[response.id][1], requestIDs[response.id][2]);
        } else if (func != null) { 
            func(response); // Used moreso for trends and get all.
        }

        delete requestIDs[response.id]; // Delete corresponding ID.
    }

    // Polls the server at a set interval requesting all data.
    const pollServer = () => {
        if (isSocketOpen()) {
            socket.send(`${convert("GET_ALL")}/${0x00}/${getID(getAll)}`);
        }
    }

    // Clears requests that will not be satisfied by the server to 
    // prevent the from accumulating to non responses.
    const clearOldRequests = () => {
        Object.keys(requestIDs).forEach(id => {
            if (Number(id) < (idNum - 3)) delete requestIDs[id];
        });
    }

    // Gets the log, separates it into a non-delimited array, to be used
    // for diplay.
    let getLog = () => { // HTTP call
        const button = document.getElementById("logBut");
        fetch(logURL)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error status: ${response.status}`);
            }
            return response.text(); // If no err, proceed.
        })
        .then(text => {
            if (text.length <= 0) throw new Error("No Log Data");
            log = text.split(logDelim); // Split by delim into array.
            button.style.backgroundColor = "green"; // Shows new log

            // Is a receipt only, Allows server to remove flag.
            if (!isSocketOpen()) return; // Block
            socket.send(`${convert("NEW_LOG_RCVD")}/${0x00}/${getID()}`); 
        })
        .catch(err => console.log(err));
    }

    const openLog = () => { // Opens the log for display.
        const button = document.getElementById("logBut");
        const logDisp = document.getElementById("log");

        if (Flags.openLog) {
            let html = "";
            log.forEach(entry => html += `${entry}<br>`);
            logDisp.innerHTML = html;
            button.innerText = "Close log";
            Flags.openLog = false;

        } else if (!Flags.openLog) {
            logDisp.innerText = ""; // Clear out.
            button.style.backgroundColor = "black";
            button.innerText = "Open log";
            Flags.openLog = true;
        }
    }

    // Qty 1 - 12. Default to 6. Gets the previous n hours of temp/hum or
    // light trends.
    let getTrends = (qty = 6) => {
        if (!isSocketOpen()) return; // Block
        socket.send(`${convert("GET_TRENDS")}/${0x00}/${getID(setTrends)}`); 
    }

    // Pass the current time in seconds from the ESP. If different than
    // real time, sends socket cmd to calibrate to real time.
    let calibrateTime = (seconds) => { // calibrates time if different
        const time = new Date();
        const padding = 2; // This prevents constant cal w/ rounding err.
        let secPastMid = (time.getHours() * 3600) + (time.getMinutes() * 60) 
            + time.getSeconds();

        // Compute time delta between machine and client.
        const delta = ((seconds - secPastMid)**2)**(1/2);

        // calibrate clock if esp time out of range. Ignore midnight switch.
        if (delta >= padding && secPastMid != 0) { 
            if (!isSocketOpen()) return; // Block
            socket.send(`${convert("CALIBRATE_TIME")}/
            ${secPastMid}/${getID(defResp)}`);
        }
    }

    let handleMain = () => {
        const units = ['F', 'C']; // Used for unit display.
        const isCal = [false, true];

        document.getElementById("main").innerText = 
            `Time: ${timeStr(allData["sysTime"])} | Calibrated: ${true}`;

        document.getElementById("mainAlt").innerText = `Temp Units: ` +
            `${units[Number(isCelcius)]} | Version: ${allData["firmv"]}`;

        document.getElementById("mainAvg").innerText = 
            `Clear Avgs @ ${timeStr(allData["avgClrTime"])}`;
    }

    let handleTempHum = () => { // Handles temperature and humidity container.

        // Checks the bounds, and if the temp/hum is out of bounds, adds class.
        let checkBounds = (data, eleReID, eleAltID) => {

            // Check that relay is in play and its has a value.
            if (data[3] != RE_OFF) { 
                // If true, check that the relay has a setting other than NONE.
                if (((data[4] == 0) && (data[0] < data[5])) ||
                    ((data[4] == 1) && (data[0] > data[5]))) {

                    eleReID.classList.add("boundBust");
                } else {
                    eleReID.classList.remove("boundBust");
                }

            } else {
                eleReID.classList.remove("boundBust");
            }

            // Next check that the alert has a setting other than NONE.
            if (((data[6] == 0) && (data[0] < data[7])) ||
                ((data[6] == 1) && (data[0] > data[7]))) {

                    eleAltID.classList.add("boundBust");
                } else {
                    eleAltID.classList.remove("boundBust");
                }
        }

        // Processes data from the allData object, to display the current
        // settings and values in the RO portion of the tempcon.
        let proc = (cont, data, name) => {
            
            const parent = document.getElementById(cont.parentID);
            const IDs = Object.keys(cont.readOnly);
            const val = document.getElementById(IDs[0]);
            const re = document.getElementById(IDs[1]);
            const alt = document.getElementById(IDs[2]);
            const U = isCelcius ? ' C' : ' F';

            // Append units onto name.
            name = (name === "Temp") ? name += U : name += ' %';

            // Set the text for the RO portions of the tempcon.
            val.innerText = `${name}: ${data[0].toFixed(1)} |` +
                ` Avg: ${data[1].toFixed(1)} |` +
                ` Prev Avg: ${data[2].toFixed(1)}`;

            re.innerText = `Plug: ${relayNum(data[3])} set to` +
                ` ${reAltCond(data[4], data[5])}`;
            
            alt.innerText = `Alert set to ${reAltCond(data[6], data[7])}`;

            parent.style.backgroundColor = sensUpBg[allData["SHTUp"]];
            // Check bounds once processed to ensure correct coloring.
            checkBounds(data, re, alt);
        }

        // changes the temperature to the correct float value.
        let manipTemp = (data) => { // Do not affect standing values.
            data[5] /= 100; // reduce int to float
            data[7] /= 100; // reduce int to float
            const prohibIdx = [3, 4, 6]; // Ignore these indicies in loop.

            if (!isCelcius) {

                data.forEach((item, idx) => {
                    if (prohibIdx.indexOf(idx) != -1) return; // match
                    data[idx] = ((item * 1.8) + 32); // Conv to F.   
                });
            }
        }

        // array with all the temperature data to process.
        let data = [allData.temp, allData.tempAvg, allData.tempAvgPrev,
            allData.tempRe, allData.tempReCond, allData.tempReVal,
            allData.tempAltCond, allData.tempAltVal];

        manipTemp(data);
        proc(tempCon, data, "Temp");

        // update array with the humidity data to process.
        data = [allData.hum, allData.humAvg, allData.humAvgPrev,
            allData.humRe, allData.humReCond, allData.humReVal,
            allData.humAltCond, allData.humAltVal];

        proc(humCon, data, "Hum"); 
    }

    let handleSoil = () => { // Handles all soil containers.
        const cont = [soil1Con, soil2Con, soil3Con, soil4Con]; // estab cont.

        // Changes RO display color if value exceeds bounds.
        let checkBounds = (data, eleAltID) => {
            if (((data[1] == 0) && (data[0] < data[2])) ||
                ((data[1] == 1) && (data[0] > data[2]))) {

                eleAltID.classList.add("boundBust");
            } else {
                eleAltID.classList.remove("boundBust");
            }
        }

        // processes data from the allData object, to diplay the current setting
        // and values in the RO portion of each soilCon.
        let proc = (cont, data, name) => {
            const parent = document.getElementById(cont.parentID);
            const IDs = Object.keys(cont.readOnly);
            const val = document.getElementById(IDs[0]);
            const alt = document.getElementById(IDs[1]);

            val.innerText = `${name.slice(0, 4)} #${name[4]}: ${data[0]}`;
            alt.innerText = `Alert set to ${reAltCond(data[1], data[2])}`;

            parent.style.backgroundColor = sensUpBg[allData[`${name}Up`]];
            checkBounds(data, alt);
        }

        cont.forEach((sensor, idx) => {
            let data = [allData[`soil${idx}`], 
                allData[`soil${idx}AltCond`], allData[`soil${idx}AltVal`]];
            proc(sensor, data, `soil${idx}`);
        });
    }

    let handlePhoto = () => {
        
        let checkBounds = (data, eleReID, darkID, durID) => {
            // Check the relay is in play nad has a value.
            if (data[3] != RE_OFF) {
                if (((data[4] == 0) && (data[0] < data[5])) || 
                    ((data[4] == 1) && (data[0] > data[5]))) {

                    eleReID.classList.add("boundBust");
                } else {
                    eleReID.classList.remove("boundBust");
                }
            }

            if (data[0] < data[7]) {
                darkID.classList.add("dark");
                durID.classList.add("dark");
            } else {
                darkID.classList.remove("dark");
                durID.classList.remove("dark");
            }
        } 

        let proc = (cont, data, name) => {
            const parent = document.getElementById(cont.parentID);
            const IDs = Object.keys(cont.readOnly);
            const val = document.getElementById(IDs[0]);
            const re = document.getElementById(IDs[1]);
            const dur = document.getElementById(IDs[2]);
            const dark = document.getElementById(IDs[3])
           
            val.innerText = `${name}: ${data[0]} | Avg: ${data[1].toFixed(1)}` +
                ` | Prev Avg: ${data[2].toFixed(1)}`;

            re.innerText = `Plug: ${relayNum(data[3])} set to` +
                ` ${reAltCond(data[4], data[5])}`;

            dur.innerText = `Light duration: ${timeStr(data[6])}`;
            dark.innerText = `Dark val set to ${data[7]}`;

            parent.style.backgroundColor = sensUpBg[allData.photoUp];
            checkBounds(data, re, dark, dur);
        }

        const data = [allData.photo, allData.photoAvg, allData.photoAvgPrev,
            allData.lightRe, allData.lightReCond, allData.lightReVal,
            allData.lightDur, allData.darkVal];

        proc(lightCon, data, "Light");
    }

    let handleSpec = () => {
        const specButtonIDs = ["CSpec", "ASpec", "PSpec"];
        const specMap = {'C': "", 'A': "Avg", 'P': "AvgPrev"}; // For JSON key

        specButtonIDs.forEach(ID => {
            const e = document.getElementById(ID);
            if (ID[0] === specDisplay) { // first char
                e.classList.add("selected");
            } else {
                e.classList.remove("selected");
            }
        });

        let counts = {}; // Used to gather all counts for comparison.
        let maxCt = 1;
        let maxClr = null;

        // Iterate to append counts with each color count. Depending on the
        // selected current, avg, or prev avg, the specMap is used to append 
        // the color with the right json key, with the counts being the value.
        Object.keys(COLORS).forEach(color => {
            const ctVal = allData[`${color}${specMap[specDisplay]}`];
            counts[color] = ctVal;

            // Set max count, and ignore clear, since its height will skew data.
            // Set color to the one with the highest value.
            maxClr = ((ctVal > maxCt) && (color != "clear")) ? color : maxClr;
            maxCt = ((ctVal > maxCt) && (color != "clear")) ? ctVal : maxCt;
            
        });

        const ctPerPix = maxCt / MAX_SPEC_PX; // Counts per pixel.

        // Iterates the counts and assigns a pixed value to each. The highest
        // val will be at ~300 px, and the rest will be relative.
        Object.keys(counts).forEach(color => {
            const bar = document.getElementById(color);
            bar.value = counts[color];
            let width = Math.floor(counts[color] / ctPerPix); // Initial width

            // Set width not to exceed max.
            width = width > MAX_SPEC_PX ? MAX_SPEC_PX : width; 

            // Displays the count value in the largest bar as a reference for
            // the others.
            if (color === maxClr || color === "clear") { // d
                document.getElementById(color).innerText = 
                    `${(counts[color] / 655.35).toFixed(2)}% of Max`;
            } else { // Remove text from rest.
                document.getElementById(color).innerText = "";
            }

            bar.style.width = `${width}px`;
        });

        document.getElementById("specCon").style.backgroundColor =
            sensUpBg[allData.specUp];
    }

    const handleRelays = () => {
        const cont = [re1Con, re2Con, re3Con, re4Con];
        
        // Ensure the same naming convention as buildRelayButtons().
        cont.forEach((re, idx) => {

            // Button stuff. Used to handle the force off function primarily.
            const val = Number(allData[`re${idx}`]);
            const off = document.getElementById(`re${idx}ConBut0`);
            const on = document.getElementById(`re${idx}ConBut1`);
            const forceOff = document.getElementById(`re${idx}ConBut2`);
            const forceRem = document.getElementById(`re${idx}ConBut3`);

            if (val === 2) { // Force off, disable all except force remove.
                off.enabled = false;
                on.enabled = false;
                forceOff.enabled = false;
                
                if (!forceRem.interval) { // Flash indicating must be clicked.
                    forceRem.interval = setInterval(() => {
                        forceRem.classList.toggle("blinker");
                    }, 500);
                }

            } else if (val === 3) { // Force removed, all reenabled.
                off.enabled = true;
                on.enabled = true;
                forceOff.enabled = true;
                if (forceRem.interval) { // If interval, remove it.
                    clearInterval(forceRem.interval);
                    forceRem.classList.remove("blinker"); // Remove if set.
                }
            }

            for (let i = 0; i < 4; i++) { // Iterate through each button
                const but = document.getElementById(`re${idx}ConBut${i}`);

                if (val === i) {
                    but.classList.add("selected");
                } else {
                    but.classList.remove("selected");
                }
            }

            const IDs = Object.keys(re.readOnly);
            const RO = document.getElementById(IDs[2]); // 3rd RO box.
            const reTmrEn = allData[`re${idx}TimerEn`];
            const reTmrOn = allData[`re${idx}TimerOn`];
            const reTmrOff = allData[`re${idx}TimerOff`];

            if (reTmrEn) {
                RO.innerText = `Timer set from ${timeStr(reTmrOn)} to ` +
                    `${timeStr(reTmrOff)}`;
            } else {
                RO.innerText = `Timer Disabled`;
            }
        });
    }

    // RECEIVED MESSAGE HANDLERS

    // Once all data is req in polling, calls this with reply.
    let getAll = (data) => { // Sets the addData object to response
        allData = data; // Allows use between poll interval waits
        
        const title = document.getElementById("title");
        title.innerHTML = `MysteryGraph Greenhouse`;

        calibrateTime(data.sysTime); // Ensures sys clock is calib to client
        handleMain(); handleTempHum(); handleSoil(); handlePhoto();
        handleSpec(); handleRelays();

        if (data.newLog === 1) getLog(); // Gets log if avail
    }

    // Requires the html element ID, and value to update it to. Only runs
    // upon a successful esp-32 change indicated in socket reply. Changes
    // innerHTML in the event the value is HTML.
    let defResp = (KVs = null, CBfunc = null) => { // Default response.
        if (KVs) {
            Object.keys(KVs).forEach(key => {
                console.log(key);
                allData[key] = KVs[key];
            });
        }
        
        if (CBfunc) CBfunc(); 
    };

    // Set the trends when received back from socker server.
    let setTrends = (data) => (trends = data); // Copies data to trends.
    let relayNum = (val) => val === RE_OFF ? "NONE" : Number(val) + 1;
    let reAltCond = (cond, val) => {
        const textConv = ["<", ">", "NONE"];
        if (cond == 2) return textConv[cond];
        return `${textConv[cond]} ${val.toFixed(1)}`;
    }

    // Pings the server to see if new firmware is available. If the server 
    // has a fw version different than the device, it will reply with the
    // new version, which will allow a clickable update.
    const checkNewFW = () => {
        return new Promise((resolve, reject) => {
        fetch(OTAURL)
        .then(res => res.json())
        .then(res => {
            const {version} = res;
            const noActionResp = ["Invalid JSON", "match", "wap", 
                "Connection open fail", "Connection init fail"];
                

            // If -1, means that there is an actual value, so the update
            // should be available in button form.
            if (noActionResp.indexOf(version) == -1) {
                const html = `<button id="FWbut" class="sleekButton" 
                    onclick="DLfirmware('${res.signatureURL}', 
                    '${res.firmwareURL}')"> Update to Version ${version}
                    </button>`;

                OTAdisp.innerHTML = html;
                resolve(200);
            }
        })
        .catch(err => reject(err));
    });
    }

    // Triggered by the DL firmware button. Downloads the OTA update,
    // and if successful, restarts the webpage. This will clear the button
    // since the versions will be matched.
    const DLfirmware = (sigURL, firURL) => {
        const URL = `${URLprotocol}://${URLbody}/OTAUpdate?url=${firURL}
            &sigurl=${sigURL}`;

        let updHTML = OTAdisp.innerHTML;

        fetch(URL)
        .then(res => res.json())
        .then(res => {
            const {status} = res;
            if (status === "OK") { // Exp response from the server.
                let secToReload = 10;
                let intervalID = setInterval(() => { // Countdown to reload
                    OTAdisp.innerText = `Restarting in ${secToReload--}`;
                    if (secToReload < 1) {
                        clearInterval(intervalID);
                        window.location.reload();
                    }
                }, 1000);
            } else {
                updHTML += " (Failed)";
                OTAdisp.innerHTML = updHTML;
            }
        })
        .catch(err => {
            updHTML += ` (Error)`;
            OTAdisp.innerHTML = updHTML;
        });
    }

    // When called, sets a timeout for 15 sec to check for OTA updates,
    // and start interval to update after n amount of time.
    let checkUpdates = () => {

        let runCheck = (curTime) => { // Runs 
            checkNewFW()
            .then(resp => {
                localStorage.setItem("OTA", curTime);
            })
            .catch(err => console.log(err));
        }

        setTimeout(() => runCheck(Date.now()), 15000); // Chk after 15 sec

        setInterval(() => {
            const lastCheck = Number(localStorage.getItem("OTA"));
            const curTime = Date.now();

            if (lastCheck === null) { // Has not been saved yet, first init.
                runCheck(curTime);
            } else {
                const expireTime = lastCheck + CHK_OTA_INTV;
                if (curTime >= expireTime) runCheck(curTime);
            }

        }, FW_CHECK_INTV);
    }

    const mainCon = buildCon("main", null, null, null, null, null, null, null,
    {
        "units": new rangeBuild(0, 1, 1), "hour": new rangeBuild(0, 23, 1),
        "min": new rangeBuild(0, 59, 1)
    }
    );

    const tempCon = buildCon("temp", 
        new cmdBuild("ATTACH_RELAYS", handleTempHum),
        new cmdBuild("SET_TEMPHUM", handleTempHum),
        new cmdBuild("SET_TEMPHUM", handleTempHum), null, null, null, null, 
        {
            "re": new rangeBuild(0, 4, 1), "reCond": new rangeBuild(0, 2, 1),
            "reSet": new rangeBuild(-30, 60, 0.5), // Celcius
            "altCond": new rangeBuild(0, 2, 1),
            "altSet": new rangeBuild(-30, 60, 0.5) // Celcius
        }
    );

    const humCon = buildCon("hum", 
        new cmdBuild("ATTACH_RELAYS", handleTempHum),
        new cmdBuild("SET_TEMPHUM", handleTempHum),
        new cmdBuild("SET_TEMPHUM", handleTempHum), null, null, null, null,
        {
            "re": new rangeBuild(0, 4, 1), "reCond": new rangeBuild(0, 2, 1),
            "reSet": new rangeBuild(1, 99, 1), 
            "altCond": new rangeBuild(0, 2, 1),
            "altSet": new rangeBuild(1, 99, 1)
        }
    );

    const soilBuilder = (num) => {
        const soilCon = buildCon(`soil${num}`, null, null,
            new cmdBuild("SET_SOIL", handleSoil), null, null, null, null,
            {
                "altCond": new rangeBuild(0, 2, 1),
                "altSet": new rangeBuild(1, 4094, 1)
            }, true
        );

        return soilCon;
    }

    const soil1Con = soilBuilder(0);
    const soil2Con = soilBuilder(1);
    const soil3Con = soilBuilder(2);
    const soil4Con = soilBuilder(3);

    const lightCon = buildCon("light", 
        new cmdBuild("ATTACH_RELAYS", handlePhoto),
        new cmdBuild("SET_LIGHT", handlePhoto), null, 
        new cmdBuild("SET_LIGHT", handlePhoto), null, null, null,
        {
            "re": new rangeBuild(0, 4, 1), "reCond": new rangeBuild(0, 2, 1),
            "reSet": new rangeBuild(1, 4094, 1), 
            "darkSet": new rangeBuild(1, 4094, 1), 
        }
    );

    const specCon = buildCon("spec", null, null, null, null, 
        new cmdBuild("SET_SPEC_INTEGRATION_TIME", handleSpec),
        new cmdBuild("SET_SPEC_GAIN", handleSpec), null,
        {
            "astep": new rangeBuild(0, 65534, 1),
            "atime": new rangeBuild(0, 255, 1),
            "again": new rangeBuild(0, 10, 1)
        }
    );

    const relayBuilder = (num) => { // Do not change naming convention with re.
        const relayCon = buildCon(`re${num}`, null, null, null, null, null, 
            null, // Relay control is within the buildRelayButtons
            new cmdBuild("RELAY_TIMER", handleRelays),
            {
                "reHour": new rangeBuild(0, 23, 1),
                "reMin": new rangeBuild(0, 59, 1),
                "reCont": new rangeBuild(0, 3, 1), 
                "reTimer": new rangeBuild(0, 86399, 1),
                "reDur": new rangeBuild(1, 1439, 1)
            }, true
        );

        return relayCon;
    }

    const re1Con = relayBuilder(0);
    const re2Con = relayBuilder(1);
    const re3Con = relayBuilder(2);
    const re4Con = relayBuilder(3);

    const allCon = [mainCon, tempCon, humCon, soil1Con, soil2Con, soil3Con, 
        soil4Con, lightCon, specCon, re1Con, re2Con, re3Con, re4Con];

    const buildContainers = () => allCon.forEach(con => buildRO(con));

    const addListeners = () => {
        allCon.forEach(con => {
            document.getElementById(con.buttonID).onclick = () => expand(con);
        });
    }

    let loadPage = () => {
        buildContainers();
        buildSpec();
        addListeners();
        initWebSocket(); // Inits the websocket protocol.
        getLog(); // Gets the log when loading the page.
        getTrends(6); // Gets the previous 6 hours of trend data.
        checkUpdates(); // Starts firmware checking timeout and interval.
    }

    </script>
    
</body>
</html>